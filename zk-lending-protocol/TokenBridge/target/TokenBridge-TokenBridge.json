{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "TokenBridge",
  "functions": [
    {
      "name": "get_config_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "token",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "portal",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::eth_address::EthAddress"
                }
              }
            ],
            "kind": "struct",
            "path": "config::Config"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHxgAAgABgEQlAAAASyUAAABMLgQAAYBELgQAAoBFKAIAAwSARCcCBAQCOw0AAwAEJiUAAADjHgIAAQAeAgACADM4AAEAAgADJwIBAQEkAgADAAAAdSUAAAEMHgIAAQknAgIAAQo4AQIDJAIAAwAAAJElAAABHi8MAAIAAScCAgACLwwAAgADHAwDAgAsAgAEAAAAAAAAAAAAAAAAAP//////////////////////////DjgCBAUkAgAFAAAA3iUAAAEwLQwDAiYoAIAEBHgADQAAAIAEgAMkAIADAAABCyoBAAEF96Hzr6Wt1Mo8AQECJioBAAEFvh4//z6k9vo8AQECJioBAAEF12M4sTxmeyc8AQECJioBAAEFWgLkG7UeqZ88AQECJi4AGMoYyg==",
      "debug_symbols": "7VjRjoIwEPwXnnnott1te79yuRhUNCQEDeolF+O/32JoQa7KxRjDAy/GkikzzLRb2HOyzpen7aKoNrtD8vF5TsrdKjsWu4pH50uaLOuiLIvton85Ec2PhSv+sM+qZng4ZvUx+QBthUiTvFo3/51CvsemKHMegb6kf/FCSg8XWvbQEEFr0tiiNaEOaMII2GrrWrBFgX3wV5pYeo185zlYsXuffPci99EG9+2Y+4DGeDQp9Vi+Q+Of1RHYoXz3avkgb+UzCS+od7CAfAuLibMIA4FFODXCYhjSwg2v3ZEIpSYfoSQ3iJBF/kfR7XNf55nn5qkn+bR4ch5G56ENsaLrTMGYgwq1r26KensYSMaWgLR+y4Dqo10MbZD8gjFoR6I0ivzWNVrQYzAAiw1rUTk1TB5hduaOMzQ7E3eG5MSdCeXXkBg5mrVxvjBqq7qzjRljZTQchCCE6MAYLdDSBRlyBMuFSgXLyY6g0Xhw32g+ma/pmDmdyaYj77zHzOlMIx03pzPddGCubFNN58Kj76wusmWZt+2Gzala9boPx599PmhE7OvdKl+f6rxpSXTdCGhe8hWlGq4fSzzQNkXBHMzzCw==",
      "brillig_names": [
        "get_config_public"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "portal",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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FwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAXACgXAhcuCoBVABcAKBcCFy4KgFUAFwAoFwIXLgqAVQAX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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "exit_to_l1_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBcJwAABAMnAgUEBCcCBgQAHxgABgAFgFgdAIBZgFkGLgiAWAABLgiAWQACLgiAWgADLgiAWwAEJQAAAF4lAAABqygCAAEEgFwnAgIEADsNAAEAAiwAgEMAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAApAIBEBGoJ5mcpAIBFBLtnroUpAIBGBDxu83IpAIBHBKVP9TopAIBIBFEOUn8pAIBJBJsFaIwpAIBKBB+D2aspAIBLBFvgzRkuAAABgEwoAIBNBAAJAQAAAYBNAAEoAYBMBAABAQCATAACgE0uAIBNgE4uAoBEgE4BAIBOAAKATi4CgEWATgEAgE4AAoBOLgKARoBOAQCATgACgE4uAoBHgE4BAIBOAAKATi4CgEiATgEAgE4AAoBOLgKASYBOAQCATgACgE4uAoBKgE4BAIBOAAKATi4CgEuATigAgE0EAEAoAIBOBAAEKACATwQAOCgAgFAEABAoAIBRBAAOKACAUgQAAygAgFMEAQAoAIBUAgAAKACAVQQAACgAgFYEAAEoAIBXAgAIJiUAABUZLQgBBgAAAQIBJwIHAQAtDgcGLQgBBgAAAQIBJwIHAAAtDgcGLQgBBgAAAQIBJwIIAAItDggGHgIABgAeAgAJADM4AAYACQAKJwIGAQEkAgAKAAACCiUAABVCJwIJAAEvDAAJAAovDAAIAAscDAsIACwCAAwAAAAAAAAAAAAAAAAA//////////////////////////8OOAgMDSQCAA0AAAJXJQAAFVQtCAEIAAABAgEnAg0EDi0IAA4tDAEPABAADQAlAAAVZi0EAAAtDA8MLQ0MAQAoAQIBLQ4BDBwMAgEAJwINBA4tCAAOLQwBDwAQAA0AJQAAFWYtBAAALQwPAi0NAg0AKA0CDS0ODQInAg4EDy0IAA8tDAMQABAADgAlAAAVZi0EAAAtDBANLQ0NAwAoAwIDLQ4DDScCAwLsJwIOAmknAg8CMicCEAKNLQgBEScCEgRlABABEgEnAxEEAQAoEQISLQwSEy0ODhMAKBMCEy0ODxMAKBMCEy0OEBMAKBMCEy0OAxMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqAVAATACgTAhMuCoBUABMAKBMCEy4KgFQAEwAoEwITLgqA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",
      "debug_symbols": "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",
      "brillig_names": [
        "exit_to_l1_public"
      ]
    },
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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vr/l2ve3XPv+lmvf33Lt+1uufX/LtR9uufbDLdd+uOXaD7dc++GWaz/ccu2HW679cMu1H2659m95rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnvLc332luf67C3P9dlbnuuztzzXZ295rs/e8lyfveW5PnvLc332luf63C3P9blbnutztzzX5255rs9N9pZvcbd8S5Fr36qw7OXwWJnOvLqh3G+yXJnnBauNPooefZI8+jLPTVYbvRI9ei169Eb06K3o0TvRoxc91yrRc60SPdcq0XOtbnyu9eseo9OkN4bf+GSbG37js21u+I1Pt7nhNz7f5obf+ISbG36h/ZIOd3dwhZ4rz31LuuNbCj1XnvsWdcu36Fu+xdzyLfaWb3G3fIu/5VtuufbNLde+ueXat7dc+/aWa9/ecu3bW659e8u1b2+59u0t17695dq3t1z79pZr391y7btbrn13y7Xvbrn23S3Xvrvl2ne3XPvulmvf3XLtu1uufX/Lte9vufb9Lde+v+Xa97dc+/6Wa9/fcu37W659f8u172+59sMt13645doPt1z74ZZrP9xy7Ydbrv1b9lh14ZZrP9xy7Ydbrv14y7Ufb7n24y3Xfrzl2o+3XPvxlms/3nLtx1uu/XjLtR9vufbTLdd+uuXaT7dc++mWaz/dcu2nW679dMu1n2659tMt136649r303TLt6hbvqWj908cL2b7qaOXdOVKteOU2tFrunKldvSerlypHb2oK1fqp39xtTH8H70sRq8vgDFGPd+J7L+Hn0QP/+P7P394+Or+4Zu0HByt1pmL6mcvoJ+WWr32L8d+Xykf39+6qWLNSMXakYp1IxXrRyo2jFRsHKnYNFCxehqp2JEclB7JQemRHNTH35nQVLEjOSg9koPSIzkoPZKD0iM5KDOSgzIjOSgzkoMyIzmoj795pqliR3JQZiQHZUZyUGYkB2X7mmftcrB3aqPYvu7Gfvlk7+NGsa3fjZ1ya7HG/lbsXEDrd9hsAa3fNbMFtH4nzBbQfH9o1bMAl7nglQ9+2bLl8ffjQl+O/164d813iGXLbX7uKltu811i2XKb7xPLlmtbKnceUlMOYh5SU55gHlKFWd66Zd6LLmYOVsGvOg3++WCh85sz6vrJvx4iPD44rhVG+/xcZRZFR4DZBiYBzCYwfgKY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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "exit_to_l1_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17456365777023668047": {
            "error_kind": "string",
            "string": "Token address is not the same as seen in storage"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3djuy6ciT8Lud6X/An+TevMjAM2+MZHODAZ2B7PuDDwO8+tbpaqlq7qGa3mmwFmeELo9c+YikVEUwmQ0rp//7lf/zrP/+f//WPf/23//n3//jLf/vv//cvf/v7v/zTf/717/92+9f//YuVt//2H//7n/7t1z//4z//6d//8y//zUkuf/zlX//tf9z+DEH+64+//M+//u1f//LfrL39/Xq0M3E72rm8H51j7eCc03Zwiebjg20odjv69rd/HO6SrR0fQ94Ojyk9js65drSPfjtarPnt6H/44y82EJojaCKhOYImgUMT5AFNzA1onHV7JFbCN6HJhOYImkJoDqBxhtAcQWPr0Dj/gCY0oBEbwvvRYovdj47ydgY3/Ay+dgYr2Zj9yotvncN6Z7fDfYhPR1cTvvF+XyCMf5JPrKrHG9l+/fZ3Mn++BJn/Eqq1jg1edv2F24z77RJ+DavWAcHtqg0uu33QL6W8qsPEXR3O+8cZoqtddjI7SEmepn1xb/EksHgyWDwFKx5vwOKxYPE4sHg8WDwCFk/44XicL25L6xLLSzw/nZ/dLYo9nvI7PrVFTPYV0kTXODoV2SJJpfhGoXVbQvewnwqn6uKY7F5LpqdLrB5sU4q7AkpoHGz2X75dYH4++Bc7iewAs5PJDjA7P13JuGDjY8/jG3g/GVDP5JTaJi87u8WRXXANbpZjUgyZXIRJSyYXYdKRyUWY9NBMWpd391ScfabyV/Ayc/ABO/jy8A9L9B9Pottc2OaQfZpCMVfLWOsfXnv67ehfsETCUoMlEZYaLFkrLH73dZy8woK9+7kKloC9lbgMFuy6fCAs4QFLsi+wYBe5l8ECXjFeBYuoXaCfYHEvsKitctPjiZISX2BRW+V+DIvaKvdjWNRWuU+5pbzWLQtVuTk+7tY8PQpUx2WcC+Uet4u9aRlLfmfHem+/40LFhQpz5UwutJcAYfIiZzgutP1RzuRCO7ZuTP7CRcBxsfvtg/KkgHpZJRuG6Zn/XH3GPO9Bu5wf6d6+VVURfcd2DSroG7ZrUEHfr12DCvp27RpU0Hdrl6CS0Hc+16CCvou4BhX0ivwaVNCr22tQEaJSQYW1bQ0V1rY1VFjb1lBhbVtDhbVtBZXM2raGCmvbGiqsbWuosLatoSJEpYIKa9saKqxta6iwtq2hwtq2hgpr2woqhbVtDRXWtjVUWNvWUGFtW0NFiEoFFda2NVRY29ZQYW1bQ4W1bQ0V1rYVVKxhcVuFhdVtFRaWt1VYWN9WYRHCUoOFFW4VloVK3MeV5mx+g+XtShcqWxtXulApWuLjTVPGNrQevNu6NIIPTzNDx6umrFmo2ibxXyDeLrSfIPFfIX6hHROJ/wrxC+0JSfxXiF9o10viv0K8kHidxC/kXJD4rxC/kDdD4r9C/EJWFYn/CvF07pQST+dOJ/GOzp1S4uncKSWezp1S4uncKSVeSLxO4uncKSWezp1S4uncKSWezp1S4unc6STe07lTSjydO6XE07lTSjydO6XEC4nXSTydO6XE07lTSjydO6XE07lTSjydO53EC507pcTTuVNKPJ07pcTTuVNKvJB4ncTTuVNKPJ07pcTTuVNKPJ07pcTTudNJfKBzp5R4OndKiadzp5R4OndKiRcSr5N4OndKiadzp5R4OndKiadzp5R4Onc6iY907pQST+dOKfF07pQST+dOKfFC4nUST+dOKfF07pQST+dOKfF07pQST+dOJ/GJzp1S4uncKSWezp1S4uncKSVeSLxO4uncKSWezp1S4uncKSWezp1S4unc6SQ+07lTSjydO6XE07lTSjydO6XEC4nXSTydO6XE07lTSjydO6XE07lTSjydO53EFzp3Somnc6eUeDp3Somnc6eUeCHxOomnc6eUeDp3Somnc6eUeDp3Somnc6eSeGfo3Cklns6dUuLp3Cklns6dUuKFxOskns6dUuLp3Cklns6dUuLp3Cklns6dTuItnTulxNO5U0o8nTulxNO5U0q8kHidxNO5U0o8nTulxNO5U0o8nTulxNO500m8o3OnlHg6d0qJp3OnlHg6d0qJFxKvk3g6d0qJp3OnlHg6d0qJp3OnlHg6dzqJ93TulBJP504p8XTulBJP504p8ULidRJP504p8XTulBJP504p8XTulBJP504n8ULnTinxdO6UEk/nTinxdO6UEi8kXifxdO6UEk/nTinxdO6UEk/nTinxdO50Eh/o3Cklns6dUuLp3Cklns6dUuKFxOskns6dUuLp3Cklns6dUuLp3Cklns6dTuIjnTulxNO5U0o8nTulxNO5U0q8kHidxNO5U0o8nTulxNO5U0o8nTulxNO500l8onOnlHg6d0qJp3OnlHg6d0qJFxKvk3g6d0qJp3OnlHg6d0qJp3OnlHg6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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    },
    {
      "name": "claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          }
        },
        "parameters": [
          {
            "name": "to",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "claim_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/+19a4hc15beqe6ubnV1l6osvyRLtu+1LT8lu6qr+uVnW+qWrPez9bJkubqrWnHiazmWPIlD7lB5QMifJISYhGQmIRBCQi4MCQnM3CQ/wsCFYYZJfgTCQAZuZsgMgdyBm9zhMgOG8bHOqvrqq3V2ndO1dnXJ6g1NV52197fWXnuttdfeZ59TmaBdMtH/saCPIiA/3Hnv/2T0fQToo1//LUXfS/2V8iTxtcRfKM3NTyr9M5S/MhlhZvzglwTfk/5LExHOrWYbH/sifHd8/TcFn0tB2z589V/Gz2f/H3b0WWzncDNoFRu+1bpgLze99GtG8Ff84Lf89oi5bu7ZfFiO+pG9Kvjv+cGvCP4xwM94wD/uB79lOyf86GdD8E9G+H3YTpkvCPYpkL0P/FIc/mk/umnhn/Ejf8tvzzb71n0s9jl77JbPnge92Nn8TEvvF7zgz7V0c9EPfismrPrBb+n/kh/8WcG/7Ad/TvCv+MFv5ZlX/eAvCv41P/jrgv++H/xWvnPdD35D8G/4wW/NWR94wZ9vxZ+bfvBbc/qHfvBb8afmB78Vf9b84Lfiw7of/Jb/1v3grwl+ww9+y383Ivxg89gVvhCuK8M15R9GeNNf/0XbD8Gtxt1DH99e/wunP//eWuOzTJt516oNr48G3SVE3dVGPXz7k7uf1dbvvluvf9a4c4cRRhTkIAY1B6h/rvbRJ8fqcfKkRLvU+OzOR7c/YbSxhGiyds5CfTubmC3lI7xxkg95T5AWbHiXa9rIs5aRf45ktV4PZ4ifyMP6EbsS3e1QZC0qNB7DHQqfHQqfokLjHK4frJuGWJcNsW4YYln28X1DrKuGWNcNsa4YYp03xLLso6V91QyxLH3bUverhliWdv+hIdZFQyxL+1ozxBrWuUPydr95R/t+zKQf/IpLF9gn4S95RBbqZ2L+CxbThFcu6M41fORIWt9Q/rhxZh30YzOINanQfIzphKPfzD+uvpZLSv2cAx/rF4JuG86RLqb86GLGNW454Cn8p6FuvbH2+a2Tt28FVEZJD6K3PVRP9uxHgm59T8ZgBfR9D10bBTws04B554tP1k/fvtu4E/QoLmeWgfGzgCkvJg0Wwn9QwWKc5IkzatHdhCJrMeh2qHqzXS/O2SYUPhpWwxDrvCHWB4ZYlwyxrhtirRpiXTXEsuzjFUOsYbWvC4ZYNw2xaoZYlvZlqa9rhliW9mXpQzcMsSxtwjKuymLW8yJogTcvsQgNk0ueozFRPQz958Lb+NinkPdPAJfrsTyYN2GyF5czBIH3hUF5kvRhjN9aeEySTrlPuRhdCV37L1hME16D2nDX+qYtkopBt13ygkvDmkyJtZUbBJqN5x2yav3gBbZr0Yo6kfo5h1xY/0FZhO6meivNth7YBpMuQnfTtbhFaL+bQyJnWIoKliyoeW0alqXof6mvcu/gDtuhEfa85/i+yL6HhedC1K3Q0P55Dp0GLJlDhZaHduPUbqcDs+DALDrkfMiBuQswzxHmw9AO4w4XLQ+QMQv/fwU8uZ6UUJcyDmPNNt1qvOcXSiXhNxrhZ4Nu2ZF/lur/3+g72oT8H+tDzo35WnmjUtuozdbq9ep6bRfhh2UE9ISHMfLAP6B22gED6zjNcmo5Rxb0hrL6yjmyJA/rR3Q5HbR9+OPbtfrh2qd3Pv+4MUKq5HCP6kQ47ja7Ssv86BpPISPUTqYkzVRZzoyCoalAMAtBpwzYdpS+oy4C5dqIUj+TAEs+jzpkicPIEEbegcGuI32fUvDEdfKEvxR9L/VXGhzusXC418J2keQKguShWfqUdok2DTSUDTElpLJep4GO9XMRo3Aa3Jjo5LdLkSdJyAkLp0UYUnl6fNiQD06ZPLU/YsjnEagzQXweNeTzKNTZQXweM+TzGNSRNED883Gg8T3BPUCzPL8mfXwi6C5C2wu82ab2AQ2XfVw0/5Q+pfXP3UBD2RAT/RP1uhvoWH9/pi3L7nwnf17m4PJCnl8ZDbrH6fGguy+PBzo2ts3Td6GHRezhCbhuaA+lJHaN/HOBT/tspzpPkDysn5SpDqod4QsEJ3WwLpYCiIT1eaXLpiCPtCVJdSaDbjM2VPGaX5MqLQj+Xj/4s4K/zw/+uuA/6Qd/UfCf8oPf2rl42g9+TfC/4we/tTvyXT/4dZkKJCbcgFRNjiPw1CNyhMXvFF1aSxqShX8u6I5xPkLyHpKH9cOp/DOKrEWiheVIs12PaaPKtZFtrG2sLcaSFB5jAOcYmr/scfBxpYZT0E4eMdd2ZI8QLe+g7XTQCkq/eIkeltPU7iEFM4yr/zLTxosbA9TNStS2EHTrBuNK+PdsD6xlwsL2zxLWcz2w3iMsbP8cYe3vgXWUsLD9fsJ63oGFuVZBaf88Yb3QA+spwsL2LxDWiz2wvkNY2P5FwnqpB9YThIXtXyKsl3tgPUlY2P5lwnqlB9bThIXtXyGsAz2wHicsbH+AsA72wNpHWNj+IGG92gPru4SF7aVtXsGK3L6VM70G17ciZxL+OZLVWJ5WzvRa0K1X1A/nTCVF1qJC41hTUviUFD4a1n5DrOcNsV4wxHrREOslQ6yXDbFeMcQ6YIglsUJiANqu5a2HpHOl8HfNlaNBtz3vJ7lHlf5ovPcrvAVDm/sxJiEtUHiGhXX/agy/XroJi+xTFRx903Jfljlt7ovtXbmvvJ5Iu3XDeSre4nqGaHga4VmiFZR+aben9hMNTyOI3jD3zVJ//nV0fZLkN/aLEt9113S1BfscjQzxC4Kt3ecQXTzr0IWf2FUtJ9XFc6SLZz3pwhUvtD0fqa+tLZ5V6uO2/a3G3ZO3bx364mLtFh62QldhcfJUj++cPBMj1hLVe46+i0uzHIiFheXg2wJcf6lHffw8rVwPi7Ys460HbdjwmmvrQeqJyb9A8i5F30v9ldYh5Jf84LcOrGpLVOyT8M8resrE/BcspgmvXNA9Rj7cU+uba5wxDU6ylH8xJdakQvMxpi84+o388w5ZtX5MUz9YR0sm/Zif1/Rkhz+3oPmWHX61dYvpZT/6meVU6WhkfGE69ZuZzrHF9DBD44cx1M4OK3NJ44HwzwXd85mPeDBN8rB+eLshr8haVGhsR3mFT17hU1Ro/EDUZrE0++tHrutGcoVl1RDrvCGWZR+txjEw7uNFQyzLPr5viPWBIdY1Q6xLhlg1Q6yrhliWNmHpj5Y+ZGkTlvq6Yoj1oSGWpe4vG2JZ6v6mIZalvixj4QVDLEt9DWsstNSXZcx5EHImS5uwnLetdB9+5vX3sNi9le7Dz7wHMCx2b2lflnHCMgew1FfdEKtBWEnX9VK/oNTX9gVlLxlvh0lb2UPBW16GexYzLj3hLTjhv5mH4UVvs1RvpdnWA/vjzhisgL7P0rXRQH8YXnsabyJGTuHL4yvyss7GlfqIx0+lrUQDH+pxb3SxqMg0DfiXIoLYAx8NWIq+l/oq1Uo+wjsYtIvoUnj7Oa5TSfzAr/DPkazGvtHaz9OOZaF+eD/vNUXWokLjMdSOKb2m8CkqNM5p+sF63xDrA0Osa4ZYlwyxaoZYVw2xLG3iuiHWeUMsS5uw1NcVQyxLfV02xLLSV/iZ7yEMi62uGmJ928cxLDcNsSz1ZTkPXTDEstTXsM5DlvqyjPeW9mUZcyz90dImLHMmK92Hn3l/aljs3kr34WfenxoWu7e0L8s4Maz5V90QqxFhFSIarif5ERDtkacDDj7Y/kACLG09LPVLSn3XPhjavbSVvYcy0Hzsg2lrfXyMQvhvZh9M9FameivNth5QBtQFYwX0vUzX4vbB+EzXf4yUL/r1dFZSPf7OjzLg3hmfpcV9ONfeq3aWdioGC1/Qh7/ojG+zwfr/Bfbtnsp3YvY6oi1jrPWVz7o+H8M/E7RtLkt1fwSyfTeSLR9060n073m81zPET/SC15D/oM7maeOk2ZG2z2ooz1qSuIzy8r6sFuMlbuBbmLD+AegjxxmMe1m69t8jpRSD7lh/pNkpw0GlP9rcEO5p//ZIZ982e+YbcbX5S8ZX+OCjxOL3oTy/M9LZF44T2Db8/DjQO+wo38b8nxFmQWnP48e+iLEoLMvNzvoynnL/getwHJP6/wtixXMUx3q9ySsur8CXbqLM8poEluEPaN7xtIevzjvCq0Dy8vhwX7QxYbt7RdFDXmnHcdhTnEkch4X/oN4s5noEH/Xq2T7WksQtlFfG8lWFJliSs6EPYf2D0Eesj5+lPV77OcVhjNkch7U8VnvkPYwdP6UYhf3ZQ31Lu47A9qxDbNdvvNdkdvndZvkgFuaMOK5xsRPv4eN4YOxEO+TY2aofCRrG7xccuR7ObeOjvWWdUmTNUv3fn25jTkaYYjcFaC/joY1PgWh7FL4ZqhuAnFiH5yORczymfiGmX0XQ6V6aE1EX2rgWYmQYU/oVFh5Xqf/IJsb1sdHesmprjSzV/xGM6x4aV9Sfa1yLRMNxFR1pcy6Pedo5F9vvcfB5lGhoO/KG2Dx9F3pYZC7COd5uLlpP/Pix8M+RrL7mau3VO6ifwayZ1ktJ5iCU13PuUNHOe8S9/gP9Eevzmgz3mnDfLEvXZiPD0PIRwbfMEwaN5doX5Tj/MukC7TUT819w+Zorn+cY4SN/CYvEd4lTBxUZeK4RPnyN+WB7qaf5Sfi3FH0v9VWqZe3cmB1+paS91soQvyV/yQ/+jNgT7+Hi2MzAdbsYNpv4GVrhnyNZfc05MyQP64fP3FUUWYsKjW28ovCpKHyKCo3vfQ0L1iVDrPcNsT4wxLLU11VDrOuGWFcMsc4bYln28YYh1rD6kKXuVw2xLO3+Q0Osi4ZYlva1ZohlaV83DbHWDbEs7d5yHC3jl2Uf60ZY4WfOtfuRq9G0w7LUl2U+8SDMQ5Z2P6z51wVDrGuGWNv519bZvWVusj2npcMa1lxuWGOhZS5nGQstx9FSX8Oaf/Fe5Lcx/7psiGXp25Y+ZKkvy3nI0oeGVfeW8ctyL21Y94Ys7csy9x3WHHNY545SYIMVFpk7+N5g+Bnfu+33PlOpIvhVT/guXWGfhH+edC107b9gMU145YLucfNxT0zrG8rvsinUQb/2KViTCs3HmM44+o38t+peYPh5jyFWnrC0e/zavVCpX1Xqa3ZSUHhLWxnbWaAZju2Ma2wxRgj/zTxvJXpbpXry83EjQbdvVGKwAvq+StdGA/15K+0MRzFGTuHL11zn3Q46+Pg4K/Jt6w9jyzkr7WcZ/Z6TmV/we85kbk17htIOf3ZDyyEM5Z/R5hs7/OqszB9Vsg0cez/xcK6SNOcQ/rmgO1b6yDlmSR7WD5/DmVNkLSo0HsM5hc+cwkfDOmiEFRa+p9QP1iVDrIuGWDVDLMs+rhpinTfEsrSJC4ZYVjahzTnbNuHGum6IdcMQa1h921L3lvq6bIhl2cdrhliW42hp91cMsazsPvzM79oZFpuoG2JZ2UT4eTv/2hpbDYLhnGvDz7zG3I6FbqyGIZZVzAk/81q+H6yXjbDCYulDljHack4b1rxwWOe0YVxbhcUyN7H0IUt9WcXo7bnj2zF3hMVybWUZC28aYlnqa3tPYet0b9nHdUOsYV0PWer+qiHWsO4X1g2xtuPE1uUT23Fi63Q/rHGiQVja2Z8iXFuJ6ssZh1LQbs/3RWd7YC0TFrafDXr3EbHeIyxsP0ft5mP44Htu0A7mFd4avmBMKtfDv6Xoe6mvMl+bVPphhz9TF/wFL/jVhtxvXwS9ZqL/wvt1uG53NqCa+J2Swj9HstrK0z6r8DrJw/rhswpvKLIWFRqP4RsKnzcUPkWFxvNtP1g1Q6xLhljnjbDCz3wvph+5LhjJFZYPDbGs9BUY99FyHDmOD4ut3jTEsvRtS5u4boi1Hb+245fPPlra/UVDLCu7Dz/zHv6w+Paw+qNljB7WudZyHFcNsR6EeehB6KOlXJZxdVjnbd4XGBb7stJX+JnPbfUj11UjucJiubYa1jlt2x+3ro/DOm8/COs0yxjNZ9O+jXb/gSGWZR5taV9rhlg+YjQ/9xmWpeh/qa9SqcpeND4HnQk6+eLemeG+eSND/ERHeA3554Juv/Oxj6/dp0L9jJB+5v3IU88QPsozr+hHxnJBoQmW3GfA+2RYfx76iPXxs7THa/8ke+9/UcHkPG9B6Q9eE/2Gv63wZYSbwgdm1jfKldnG/Gxprladrc9VZuoz86V6dXajXF4ozyxWFyqVjfXqQn1hprIxMz+zzs+OiqzI19MYV5P6gPDPBV59suyyOe1+tGZz0pZtISxnm+16aWzB0q40ueQ3kfh3LgU/LH5tobK2WVvw9PsyTlvQ3nOQxhbCzy/B537Hj3PqfrCuGmJdM8S6ZIi1aoh13hCrZoh1wxDLso8XDbEs+/i+IdYHRljhZ75fMSz2ZemPlvZlGQst5bpuiGVp9992mwg/8z3SYbEv3msdlj5a2v1lQyxLu79piLUdJ74dc4dlH9cNsazyibAMq+7rhljbPpRu7uDnBLZ96P7UveXa3XKN3IiwZA/pJaAtRf9L/ZXW+w9ftsee4Xc3GmJXeF+tD+w6X9Ceg7DbI6uWtGcdMna6aeG/Ya73ymyv33Z/abyzT29GdeJ+2/05oGP9vz/RxjwQYUq/dnrRW7Wa5HfUH4frdjYxU8oQvyDQ93GF/6B+R/1xkof1w/u4exRZiwqNx3CPwmePwqeo0Dh+94P1oSHWRUOsG4ZYa4ZYlwyxbg6pXKuGWOcNsS4MqVw1QyxLu7eUy1L31wyxLMfRUveXDbEs+1g3wgo/8++X9iNXo2mHZamv64ZYw+rblnOH5BPyfDrmj68EnTS0pQPE7wmgIb7kpfuAbpkHCv5TfvBbv5fyZNCtY+yT8Jc8cy/Uz8T8FyymCa8cYVnrztU3lJ/t50mQB3UQh/VkSqxJheZjTPc5+o388w5ZtX48QTrR+GhrFKn/tEMurC9+ibYvbUWH3wGaoQ5nXOP9NPAU/pv5rRnR29NUb6XZ1gPr/qkYrIC+P03XRgEPi+gY17GPE9Zj1Ie48S0q7aVekrW9nzhQSfw7GcJ/UGv7vQn1Krrbp8haVGi8ttf8c5/Cp6jQeG3fD9aHhlgXDbFuGGKtGWJdMsS6OaRyrRpinTfEqhthhZ95XdKPXI2mHZalvq4bYln6Y80Qy9LuLWOh5TheNsSyHEfL+GWprw8MsS4YYlnqy9KHLPMJS31dM8TajqtbF1etdB9+fiGwwQqLpd1b6T78zOcvh8XuLe3LMk5cMcQa1nz1tcAGKyyN5r3/ftf47bMuw7anhr8Jm4n5L1hME145wjLuW9nVN5TfZTOog37tT7A87623xnSvo9/IP+0+TJJ90qQ6mSasaQXLteeadGwLQfd4SlvPPtbac30iiNcT8t/MnqvobYbqLTfbeuCx2xuDFdB3fh6/154rjumjREP7KxKfndS/Xn6K7Xc6+Ozuk8/uhHzu5/70On+3e0LnGXf+bg/Qsf4tOH+3d6Kzj9h+V9BJQ5t6mGh5oD1CNNSb1BN/LwDNzt/LJdGljCcWoT0EvKeItgto2G8uo/Qd+xTGj58ALtdjeVCHKBti4lhres1S/Zcn2rK8nNcxM4CJcq40O+uLLseDdr+xDssg9V8FGZ7L65hjMf0qxGCugA2XJ3TMINB9kfv1EPUrLqZkqf4s9GsvKA7ryHecU+WdB8Jrl8IriLnGtrErhpaWL+pHrj2cgG9GobEtsT6xfZzO2Zak/jsOW8orMqA+eNx3kgxc5yGSQeofVmQI9SwxZP32p18crn165/OPGwGVMfjMoV4bah6CvIITV0QNYffEXRhHvrvMRHPHIOZa3LBPw/V64+PG3UaMgkYIbCqG2UigF46l0i4sfuecezkm8gsCfe0l/HOBbrdLNvKUOc6LPKwfvhdcVGRNmx9hnzi+JMmPXLFjZ8L+TAdtw75z9/ZncTaHc7hmc9Mx/DNK+4DaZpRrYQmd8lLklJPE19gOWu8zmlZk1HKPDNGwv2wr7EtIQ1sZIxrOF1mi4dwyTrSHgTZBtEeAtoNojwJtkmh4FiMHn7louZ6MWcjvK8DlelLC/mxEgodtv21rGMYaCbrXJmGR3/YR2/dzHma9JPLImjsuf34M6Fj/M5jrD1K+oZ1delzRF8uA9bHfPFZos7zfo/HWcly/e6Nt/e4D/Wl92wt0rP9XHPrV9s5c+u21fyryiH5Rp/sIq5d+l5v3/g+7fv/6FupX2+fUzgRyvEt7JrDokAH57O6Tz26FjwurqGDhOuHrRPijX2h8dvr23darLwUS1RrQ50m6Nk3fOfV9NEbUuNRavj9B3/l2wzP0/SFFPq2IHFhYltGgdxFTF139XTD1Epm6NrUhTwmXvAWHbXELTszrLajHZvyWwhOvucxY6ml8+NGCt5V2GaKhDG87ZMD2Uk9C3DtAswtx1VaIE7y47cx3gI71f9kR4qQN9v9Zpf8sA9bHfos8mu6lbV7hnYn5L3z4Go8LyrB/QHyejz4XFBrbuqbndxx8sP07A+pPcUB8CgPikx8QH749sWTIZwnqyO0Ksbd3gcZx7V3iw9dcce1d6s9bhv3R4nReka9fPqgbfpzsENBwjhM5DitySIxfhuuGWxCJX2ss/HMkq7E8ra2xZZKH9cPbHSuKrEWFxq+oXFH4rCh8NKz9hlhiG4Wg21YOE59DCp9DDj6HFT5iV0eBZpg7LMi4vBd0F6Edg2sbzbYcXLTtHZE7zC0q+TYu12OeqNdjREMfO040HKsTRDsCtJPR50LQrV/kjTTpI1/jccT2R0kGbNdvDNNk1uxymfqT1i6XFT55pV2//dFk5jG34IP9WSE+K4Z80BaPEJ83oR0eUfgjuhUr7TCnx7ayDZil+r8y3cb8KW2THwO5DGNJTfp2POguQjsBvNk3TgKN7ewU0Ng2TgMNdc5Fi0+iizA+XUwRn94DmvRJxqC1tRHtoYdj8NVEZ3scQ35VPs6fR4h2RKF9M8a5tjyoBzwWgPsTbDdSf28ks995Z25em1s4lzruiXcSf9bmFpRH5M4ptLE+ZN1YXyhVSnNz9cZcdW22upEJun1qVLnG6/ATSv2qUl90fdKPrmfEl0abbXycl8MyBrTjRMsCTWQMTfR7+U75T3iSP4n+kX9Rqf8e9CHNWPrEwnhggbVzk1i7gu45SWKO59x3UYtBUjSfLxENba5CNPSnWaLhXIa3jbn0yqf/cor5CufF4zGYMhfgWkDmmCzVfQXmthd3dPLCnPBYs5OGuZfwCTEO7WhfRz54TkfmybCciZHrHZq/POU6dS3X4fnrhCfeSecvXv+gPCJ3TqH1M3+tlTcqjdLaWnVmrT47Nzfnmo/wGs9fJ5X6i0p90fUpP7pe0+avk6DXsIwBjec2nL9ERm3+8jP/VteS6B/5F5X6p6EPacZSYruWN2nr/NeJhms+zHUPkY/7yRPvjT33LSAZcdx4fkCb5PkB1yw8P5wBWtr5QXSRdn7AOIl9QswxuKbF+CzVPwdzxBmaI3BOF95hvd+geicUuf36TPK9VuGvxVAfe61aTNT8TrM/9u9T0O5cs12PaaPKtZEYrPAzvqatXyyxi0LQbaMniM8xhc8xB58TCh+xK/Q/u3GcbT1ScTboLkI7B9fS7rWK3Gn3WlGv54iGPnaeaDhWF4iG8e1i9LkQdOsXeSNN+sjXeByx/RmSAdtlYv4LH77GfDSZNbvk2JnWLk8qfFx7JZvtjyYzj7kFH+zPKeJzypAP2uJp4oM5Ou61fp/WHNIO91q1tXeW6v8j2GttUm6CfrBVsUTzjfNAYzu7ADS2jYtAQ51z0eKT6CLtXivGauwTyp40N5H6f4fGyVMuUdpF/dJ06toDHbYcx8962p3jaPEyTY4TfuafROknL1k2xBLbLgRBbF6SIRryOeHgo+VLD2qOo8WQQeU4nKumzXGw/aByHJddco6T1i5PKnxc673N9keT+UHLcX5olOP8Nchx/vNA9l9scxy2M185Du6/pMlxXGuwXnslGeIdlwsdb977z/s0vw37NL+1I16uo8D7yGRnve19mgd3n0bsQjtLxXNf2rNU2nmRBzWHQb0OOodB3kiTPvbKYbD9oHIYl11yDpPWLk8qfPJKu377o8n8oOUwf2qUw/x5yGG+ug/3adjO7qd9GryfnyQ3kfpTUZ4xDPs0h5T++z2jkjzHEf45ktVXjqPFS+0MsTY/SVst9vA+jZZLnVT4aFjLhli8HtbORGeIhnyWHXy0c8+ezzU0eP7Hos3LaXMckTttjoN65ViIPnaWaGn3dwpBt3773dfD9oOaQ5epPygD52xp7fKowievtOu3P5rMvnOprdp3istx5ifbbbBd0hxH6l+AHOd1mjs9nZNJFUs03zgLNLYzzCPYNrT9naTxabP7NBirOT7hXonU0/ZKNN/xnEc0ktiylkd4ep7RmUdoMSk0a/l5rVuNu2c/X/v4o/UTjS/uvPtJ/Wzts7sf1T5+t17/rHHnDvaGrYZ7y9bCdeRzSbmOGMd79GKlee+/thI9TlgnemAtE5Z2Cp2jSBzWe4SlRS6e+TRv42wK66M8p3rIc7QZL88pwjrtwAo/y1sttJn+NGGd6YH1FGFh+zPU7mwMH6yD0fCswlvDZ7s910Pm75DMKBevzs73wHqCsLD9ecK60APrScLC9heo3cUYPlgHV8EXgXdGuabJ87RDnouEtdoD63HCwvarhHWpBxa/8AfbX6J2l2P4YJ1LcP0y8M4o1zR5vuuQR9ommeFQVsMZJfGpeOE/qBnOpdew8Er5iiJrUaFxdn9F4XNF4aNhHTfEOmmIdcIQ65Qh1hlDrLOGWOcMsS4YYp03xLpoiCUxUbvjMUN80t7xwPaDuuMxQ3xwRw5Xm/+AVptig7jaxJUOvjwP678Jq81/GGFqOxEio6Zn3nVJq2eNj8w1aMOGu/pzol+cw6UIDee5efjMRVuditxpd89QrzwnY5y5QjSMG1eJhr57LfpcCLr1yzFRywPxmsuO+S4ltuvXXzSZNbvkuJzWLs8qfHz7P++KnjXko60f2H4s+Ghri17x7Nconkm7uHj2XaBj/f0Qz/4T7Z6hH2xlLGHf0PISoV0FGtvGNaChzrlo8Ul0kXb3DGM1xyfNJyaDbtvbirtrwj8XdPucjzWDtiegxRotfktbzZ9egs/st6PKNZdvLhtiyVrSlTtkiIZ8XHcxtFzDc35Q5bvwWPLU57Ckvbu22fwA9bpKNPSxS0TDsWK/xbgosUjLD9he0uYH2H5Q+YHr7hrnB2nt0nXXw9fdtQc1P/h/KfKDsPDdNam/E/KDP6b8wNNpxFSxRPMN3PdjO8O8gm0jbl+BS68Tjpu9u7YK+KxfrDcW6PuVZ4J4uTIKDvvcoRj+YTnZ7KSdTSBb3J5/EOjxRLvTGCfbWUU2xh1x9COOjxajtFg4R7KnjYVzCp8ke8me8sJKktiE/Ae1l3w2oV7T5oXsF/3kcodIBoyrPH6e8ujEeb3wH9SpOW0PYU7R6yDsO26clx3y+FkDt39cVssJtVOFDwX35uC4uBqXJyAPtIe4sUHeK817/5OsUc72wFomLNe+07keWHwPX9MB+zDX07DjeMfNdYFyXfIn1BWftDpHdbWTQqILGceRGBnOAR3HmvuSUepreHw/+oJSDzH5/nPaNYv4GeZzWxEXhX9O6bePuKjdV9fWgqHfTwSdumabwfGLOz9yWukrx4NeMnE8SHuvH7GWCUu712+51tX2HPvFumyApa3BLxIN1zOrRMP1DOchVxT5xN9wn3Qr/E3450hWX/52leRh/Wj+FjffaWsEV52rwFeuhX/XesjE/oZjdo2w3u+BtUxY2F7ajgTdY6Gdk3q/B13bHwvg2nXih3hXqe5VqqudVYr7fj0FLspwjepec8iwSnXPx/DRxmwVcOU66l78OW2MOE807awU39d+P3fvf5hj3szF8z3h4HvKwVfmH8Tnp9VqIEPDIcOyQ4YzDhnOBt34I0G3H2MuO0L9RnnlO/Z9RJGT2yMN62OuKnjaudALRMN5/hLxOaPwiTuvid93xPSD9WtpG8xP7KOk8OA8+06uLffT0auZk+yneHoyPvE8KPwHtZ/S66w15zjaGWjXE/HsD8jH9SQRYh03xJKzeQ/q02Wup9BRzz6eLuvXJrD9oJ4ucz1Bz3aZ9gn64wqfvNKu3/5oMvOYW/DRnsNg+7Hg43q6LO7+1y/Rr4NoT5e57n9J/Z9PtTH/WYTp+Q3Wpk+XsZ1hjsG20c/TZfhLFZs9HxP39Cu29ftkX2k26bzNb5P39BRba97WnrfSYk14u1aeybjVuHui8cWl2scf1Wt3P7r9yfnGX/y8cecudgOhx+A60rGMETupt0z1jjS762EZ1MO7SdV3tBkvF7vJFphl9X43Sy2tkLZamH8DPvN0Mqpcc00Z/b5UErEG/fC556mmrqVTUrRpKG3aitPCZo9t8UtzXC/ATpvSFoJu/fb7Eg1sP6gXGLnsku0/rV0eU/i4ltab7Y8mM4+5BR/sz1alx3Fp648pbcXtjiRpq9T/MaStv09pq6cfl0oVSzTf0I6taikt24aW0iaNT/jjUps9tsXxCX/oUH60SWiHoR3/ECf+WKvg4w8dar4tP7pdoO/h56Xoc5bk2hHZxiTVs7WHSssetB8Y9WuLlcSPxsYtw1FuLZca60PWmcba+lyttlFZ3yit1zYaGcIXWfkabuFyTJT6B5X6fnPTSk38BX8wCn00LGNA49dTZIGGLynhH4zy8yL2Si2J/pF/Uam/0mzXSzOWSdYuSbHkx6fwh++Wos9abGJfXILrW7F2EX45ktVYntbaZSno1uubil61nFTacu4SFn5pbdp8S4vvFlgy92hzxZvE5x2FzzsOPm8qMg/Tj1mGJe3aZbM/5I565fxyCWicE7rWDejTkl9pW9RsL2njELYf1BZ1khxms3a5pPDJK+367Y8mM4+5BZ8lqDOotRjnqXFrl+pUuw22S7p2kfq/AWuXecpV0Q+2KpZovoF7C2xnuE5fIhreekKdc9Hik+iin7ULxyfNJ4Y1P3jHjzzO/ECLNWnyg/BzGT6z36ad098zxBK7KATxsdOlmyUHHy0+Pqj5wRLQ2P+0o7yW+cESfEaa9LFXfoDtB5UfLFF/UAbU12bs8pDCx/e8fYj4HDLkg/3ZqvwA11CYH3wvQX6AbePyg38H+cGnlB/4mRNs84MlomF+wLbRT34gukibH+Ba7ngMZlap+zbRpO73Ybx+JfpcUNq/FXTS3gLau0R7G2hvEu0dBZPjA9oc1l+gPkj9vxnJHerymZ065kig5wlix2Kj6KN2Nrpe4hwA+7gEPA9RH6X+34Y+HiR7wb090X30NHgw1vTSn3Iox346yil28I38wJfj6KhSn/dPtVxJmw+S5F1vK1hLcG2lee//VtoA+kycDXyZ0AZEr1thA4L9jfzAN84GsH5aGxCdufbTMkG3rbHOwzJoGxD50AbeBZ5sA1L/nye0gaWg3Z+wjDW99Ee1AdRrEhvA+mwDh5X6ODais2LQPe5HCGtJwcK5YIVkFezxQJ+PBC9L9X8AY7Q33ymfNicL7S0FG+flDGFgP6aUfuSJhm1D3JfGO+WXHO7fQ07wI8rh/NznaT8CLjmNlncif/7RwF9V/CJDbVBf2l4By4D1jyk6LJDesK1ffVVr2hpZipbXcs6bdN+Lc148I8BrGDwjgDrhouXDoqdw/N6AeML1pKBtZoin8GBfYb94U5EX10LsF78JfvG7Q+AXGAfj/OK/pvQL7R5bUr/gPar73S94rxj9Yolow+QXv5vAL3AeZr84pMiL9xD4PNPvgV/8jPwCdebDL7Qf30P5TwWdMkv9P3D4xSlFX66zHtpPP2gxVHtcUNoO0yNQ6AfaGS+2bzzjxee/8LEF3k/VHk9M6heipzR+8TPyC+2scVK/OAG4P6ZHZkV3fwJ+MRW9qs3vDzy2/ULGMs4v0G+w/lcOv3D9xElY2C+0V9hgv9kvMPbyq7P96Ku6kVdklaLZ/imiJf1BqCS2LzR8dQfqhIvmF/iIcFK/ENvMEE/hkcYvTgLuL5FftB59h9cWPkN+gX334Rf4iL3mFxeDTpml/iORnJpfaD/por0el2XA+thv9gvtlQZ+9TU7m1dklSI0fIScXyeEj5DzfKH93ITQ8JUM/GgrvqKBf34Hi+YXoqc0fvEM+YX2Oo2kfnEecOX1n+wXL4BfLA7GL+rSNxnLpH4h9V9J6Reu+UJ7LVFSv5C2nv1iqF6PLjTtlS8+/WLRk1/8Gv1kh/aTBcKz12vohKffV2uX1tnW4/znAtCx/iGH/7h+uiws7D+av2mviHP9tNhWxptzijwcb44p+tL2v89Cf8Iy1vTSn4a2/43jlgW+vcYoLGljougsyauGXD9pckjBxJ/m4bXNKsxVt4ZgbYP39+PWNlcdvqatbTCepF3biDzflrUN53AYO3jdM0xrm1sJ1ja4V8hz1XFFXvyBZN5X+hj84hfJLwb1+tw4vzgbdMos9T91+IX26ljteWzXvIz9Zr9A25e2fvU1W84rskrR7JvzNLRvtn3Nvnktpfkaxm3+mVYsml+IntL4xS+SX2jxL6lf4Ovj/jR6Nxn7xd8Av/jyPvGLv5XSL/B+yoPuF0ni/jD6xZee/OKHMX7xj8EvfnCf+MU/3Z4vWiWtX/D9kfvFL37gyS++T34hZ3b+LfjFr5Nf4Pk+H36B99K1MyjvBZ0yS/3/4PALaYP6OgzX2C+0e/PYbz6DgmedpK1ffdmeu+ZzJtr7U7T78Hy+HX0BdcJF8wvRUxq/+HXyiyPEA8cqLOwXbyryhrh/NHHvs4xvEeodCDppB4G2J+iU51VFHqw/RfVfAxm0+oKXpfq/BbYvZ97E/krQ3tBf10TmMsg0qvSrRDJL/f/m8Fdpg3p7Ba6xv5aV+thvkadAesO2k/Tdl75mFH29qsiTpfr/I+HeWxH6E5axppf+rGt7bzhuWeDba4zCwmM6o9THsRGdFak+jq/QDgCtRDT02YMkQ1GRIelZT2kb+vJjUcDTYgbHE7QFjievKfJgfY4nJZBBqy94/Drp/+OIJ578o+byD+xXnH/8xBFPNNsrwLW0tsfxBGONtJ0Muu3SRzypKPp6TZEnS/V/ljCeHIT+hGWs6aU/ajzBceN44hqjsPCYVpT6rphRARrHDIwnZaKhz75KMhxUZEgaT6Rt6MvjFE+w3vPE84DCE+fS5ea9/5OKzD7uPWHMGQ269RmX44xHxqn5t5Zn7YZrbAu94qgrx5O2nvW15tLXKwn0lVf0pfn3FPQnLGNNL/1R/Rttk/1bG1Osn3ZMRWfFoDtGHiQa+tAB4jOl8EF/Yh/GsZK2oQ//TtSBHNDl/1iweb2vr82tVcP3qJWrc5Vqqb6L8MMiupvywL86W5tfr82Xy4vVcqNanh00/8ZadXF+bXF9tlQvLZYXK4PmP19b+Jr7YrVWnSutl+bnBs1/ZmFhbnFmrVSdr69v1KsD7/9afW69tFgp12u1+a+7vzDw/tfrjXK1PL+40KhW64uDt7+Fxa8Nb6NRK5fLM/VSY9D8Z+trC6X5mdpifX2uXpld78U/jMt/GH2XmDUCdaWdzHejcN1wfkj8rhu5liNZjeVpvetmlORh/YyQ7sYUWYtEC8uRZrse00aVayMDxioE3ePNc66mm1EHHx6rsOSVdmxzrNOl6Hupv5L4Jw2Efy7w6gNl1/hpehXdZRVZi0QLC9tJVuGTVfjcL1jSPizsj2E51eyk4RizTpPaqrzHhWNpIYgfG+EdPQLccT2ryJul+tdoT2aCZF2Kvpf6LDx3IK9JpX+GvFtnfceD7pJX+s3jvgNoPLaTJDPScD7m3/3AMkrfURch719IcA9Ds5EM0caVfgiNxz0sxaDbtrNEQ9seJxrGtgmioS/J+7szhBkEbZ/FsVtpdsqu+d4UXJ9oduJ98x+uZaPPot8dWJ9ok0Aba7b5hiUXfR8DPoglcmSp/l+KwGUfcRzaSPuiwn+c+HfIrVzDsWKsUeWa1P/mHVCRjHF5Ho4Pz7meYkriOVf454JuP/Ax506QPKwfjiE7FFmLRAvL2Wa7HtNGlWsjMVjsM/1ijRhiSVzQfHuc+GQUPhkHH24flkml3VL0v5SuVPmCYPMcsUl8LjWeZ7Bo+76av6D+sKDcad+9iPYwRTScB6eJhnEiTzS0kWg6dMb/zdoIt0cZsF0m5r/wCXrw0WQuKDJwnqfNjSMOPmMKH9fafLP90WTW8uZ++WB/JojPhCEftMUdxAfzanz34r+iewnSDvfbse3RZpuO9XfsbGP+G8rP0Q8MY8ki57NYtHyWfQPjDNvZNNDYNvJAQ51z0eJTS19Buncv4jyQA3z2y1Gl7fZ+lv/9LM5zNrsHxWPdL5boelDzjuf8eYHnVixaPNhotuXgovmnyJ02f0C9ThIN7T5HNBwrzjvQDiQeaWvfDH3Wcnm85prXBzU/uexylOqltctRhY/vfCjJfu5m+WCdQeUp48QnLn/4PcofpF1c/sDvbpb6P823Mf835Q+e9thSxRLNN5LmFmwbWm6RUWTotceWJn/AWM3xSZsTpoLuMfr/MEbZKN/znOO1zsWLzJpdIf8s1f+549yMtubXcgGWAetjv0Uebe9S2g5bTsw2ra29Nbtlm8acmGPUTqChTrj0ypeTnovP0nu4x4kHx6SVZqe8WUVejHW89snB2mcf+YWnfZSq9E3GMs4v0G+w/s5ITs0vNDvX9gJZBqyP/Wa/QNuXtsO676TZPq8Rkto++1oBaKgTLr32uZL6xT7yCy3+JfWLHYArewjmZ4lm1mdrldnF0npjdr42Nz/ws1wbX3PdmC/NztSrjZl6rRd/7V4InjUMi9xPwfstWF/wslT/JYgxr9B4ZxV+Yb3XHfUyMf+/wVCujTU7r2n3YfD+lNQX3rlmt4xCmwJalvhMR99RX4glcmSp/nzUdxkTvKck7YsK/x3Ev0Nu5Rrfn5pS6k8p9cPxKUUytmI48Lbe+/iGJ+HjNZZNbCfuvj7fj0IarvN4L0LihrYnGha+5y/1Dw1mXlXv+U9SHyagD9r8yGscqX8DfHhlZ6fOtPs8mj55353zSKSh3KJv0d+UH/218nWZLzEvQVmngk4dSf1TSl6indseh/6EZazppT9V7dw25hDos9ivIGj3G+tz7jSt1MexEZ0Vg+48hM9NaOeGcI5fIVkxt3WtZ3gdeAXGiH9jAP0mR7Jj3/me8ajCV9uXmASZP6eY4Oke+by2FyZFu9fHuSP6IeeOOZIZaWgHafcJRBdpz+JYxCHMgb+Rr9kt11b4La5r2G9da5gg6PbbXn4ue2TFoHss2b61uSaNz4RlhfihvWCu/nnMvN5rn++LmDV12n2+vwdz4F+lOdDyHFgvu+TxFX4SS9gvl6Lvpf5K4vM/wj8XBD7znbLL/rU1v+f8oeqaFzV/fCi4t8bmMUP5BAv3yuU+tmuvjm29l26KSns+X4hj7DqXyHEgyblEtPepwJ2rZwgrbv+I54Oke2mc+34Jfv+r5Peu+0LamS0tv2W/186xiu3yPuZS9L3UX2nZbmu9Heg6xdwY6/+yY09O8wftfBrLgPW13FF7hrZ1bpS+G+urtVbY2UNfedKX1P8XDn1p/Z9w6GunUj/v0BfqEtsy77hYNChb7KVbtkWp/4OE67Ad0J+wjDW99GdWy+cwB8sC3zh/wfpJxl/zlyLVx/F23U/XYvwU0TA2c/zHGC+xDWNpr3sXkr/9GZvmxH1XUQIA",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_for_L1_to_L2_message_consumption",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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TZHu3HON92vVPc29nnfuZTnx3N2J5+41z3373lTCiecuJ557PPHcVa/v23ymql5ntu+rVfU605m76nWmM/ep68znGeL0M6TpZ8jTz1Cmn2EA+6ty4woxSO89jcuzmlvhXVrc+8HLdyXlMuKTzndN3Z136v68Uw/nnbqcd+rxvFNP5516Pu/Uy3mnft67qTvv3dSd927qzns3dee9m474wPZdUz/v3dSd927qzns3dee9mzo9d9OP6Xg9d8jP6ei5631OR8+d7HM6eu5On9PRc8f5nI6eu8jndPTcGT6no2e1/5yOnhX8czq6VuWga1UOulbloGtVDrpW5aBrVQ66VuWga1UOulbloGtVDrpWZdG1KouuVVl0rcqia1UWXauy6FqVRdeqLLpWZdG1KouuVTnqWpWjrlU56lqVo65VOepalaOuVTnqWpWjrlU56lqVo65VOelalZOuVTnpWpWTrlU56VqVk65VOelalZOuVTnpWpWTrlU561qVs65VOetalbOuVTnrWpWzrlU561qVs65VOetalbOuVbnoWpWLrlW56FqVi65VuehalYuuVbnoWpWLrlW56FqVi65VuepalauuVbnqWpWrrlW56lqVq65VuepalauuVbnqWpUVfUt7mU5V9H3s53RUrcpV0Xesn9NRtSrXRdWqXBV9Q/o5HVWrclX0refndFStylXRN5kf01H0neXndHStyoq+h/ycjq5VWdF3i5/T0bUqK/q+8HM6ulZlRd8Bfk5H16qs69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbvqrr276q69u+quvbPrfo+rjvMh9V6/JlPqoW5st8VK3Ml/moWpov81G1Nn9siaxsPkevznW5/bKroTGfw5fnnNb51OVxPs8Hl0V+HVsepu6bx16ao1/HXtb43469xlkx4jz+s8Q3xelA4vQgcQaQOAUkzggSZwKJM4PECcKHHAgf8iB8yIPwIQ/ChzwIHzr+o+s3xQnCh7wZPpRux36IkI1AzRCiXqBmGFEvUDOUqBNoMMOJeoGaIUW9QPWwout89LCX63xE2Xz0sIHrfPTcta/z0XNzvc5Hzz3wOh89t6rP+YieO8p1PnoW/ut8lK3Pomx9PtpOwLtcfx0sucbtG7WEcjs2yXro5RdaP3x/3Bqc6zCAtKy/nJYc7j/t4q+0RMi0RLmxnRTz0khLYlpaaclMSysthWlppaUyLY20HG2/cZa0OKallRbPtLTSEpiWVlqEaWmlhSy3mRay3GZayHKbaSHLbaaFLLeVlkSW20wLWW4zLWS5zbSQ5TbTIkxLKy1kuc20kOU200KW20wLWW4zLWS5rbRkstxmWshym2khy22mhSy3mRZhWlppIcttpoUst5kWstxmWshym2khy22lpZDlNtNClttMC1luMy1kuc20CNPSSgtZbjMtZLnNtJDlNtNClttMC1luKy2VLLeZFrLcZlrIcptpIcttpkWYllZayHKbaSHLbaaFLLeZFrLcZlrIchtpcQtZbjMtZLnNtJDlNtNClttMizAtrbSQ5TbTQpbbTAtZbjMtZLnNtJDlttLiyHKbaSHLbaaFLLeZFrLcZlqEaWmlhSy3mRay3GZayHKbaSHLbaaFLLeVFk+W20wLWW4zLWS5zbSQ5TbTIkxLKy1kuc20kOU200KW20wLWW4zLWS5rbQEstxmWshym2khy22mhSy3mRZhWlppIcttpoUst5kWstxmWshym2khy22lRchym2khy22mhSy3mRay3GZahGlppYUst5kWstxmWshym2khy22mhSy3lRbufdZOC1luMy1kuc20kOU20yJMSystZLnNtJDlNtNClttMC1luMy1kua20cO+zdlrIcptpIcttpoUst5kWYVpaaSHLbaaFLLeZFrLcZlrIcptpIcttpYV7n7XTQpbbTAtZbjMtZLnNtAjT0koLWW4zLWS5zbSQ5TbTQpbbTAtZbist3PusnRay3GZayHKbaSHLbaZFmJZWWshym2khy22mhSy3mRay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",
      "brillig_names": [
        "discover_new_notes",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "build_msg_block",
        "attach_len_to_msg_block",
        "build_msg_block",
        "get_l1_to_l2_membership_witness",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_config_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_config_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_for_L1_to_L2_message_consumption",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "107": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "110": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "114": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "115": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "116": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "118": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "119": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "129": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "132": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "135": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "136": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "138": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "139": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "140": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "141": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = array::subarray(returned_message, 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"
    },
    "144": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "145": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "146": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "149": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "150": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<RetrievedNote<Note>>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter TODO(benesjan): try removing this.\n) -> [Option<RetrievedNote<Note>>; S]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            placeholder_opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "152": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "153": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "162": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "177": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "179": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "180": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "181": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "183": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "184": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "186": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "188": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "192": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "210": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "246": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "253": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "254": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "268": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "270": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "271": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "281": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "285": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "287": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "288": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "297": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "322": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "326": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "327": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "343": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "344": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "346": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "358": {
      "path": "/Users/yash/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "387": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "388": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr",
      "source": "// docs:start:mint_to_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::{hash::sha256_to_field, traits::ToField};\n\n// Computes a content hash of a deposit/mint_to_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_public_content_hash(owner: AztecAddress, amount: u128) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector =\n        comptime { keccak256::keccak256(\"mint_to_public(bytes32,uint256)\".as_bytes(), 31) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_to_public_content_hash_nr\n\n// docs:start:get_mint_to_private_content_hash\n// Computes a content hash of a deposit/mint_to_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_private_content_hash(amount: u128) -> Field {\n    let mut hash_bytes = [0; 36];\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { keccak256::keccak256(\"mint_to_private(uint256)\".as_bytes(), 24) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_to_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(\n    recipient: EthAddress,\n    amount: u128,\n    caller_on_l1: EthAddress,\n) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector =\n        comptime { keccak256::keccak256(\"withdraw(address,uint256,address)\".as_bytes(), 33) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "55": {
      "path": "/Users/yash/Development/hackathons/trifectra/token-bridge-tutorial/token-bridge-tutorial/zk-lending-protocol/TokenBridge/src/main.nr",
      "source": "mod config;\n\n// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract TokenBridge {\n    use crate::config::Config;\n\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{functions::{initializer, private, public, view}, storage::storage};\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal: EthAddress) {\n        storage.config.initialize(Config { token, portal });\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    // docs:start:get_config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n    // docs:end:get_config\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: u128, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        let config = storage.config.read();\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, config.portal, message_leaf_index);\n\n        // Mint tokens\n        Token::at(config.token).mint_to_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: u128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        let config = storage.config.read();\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(config.token).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n\n    // docs:start:claim_private\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: u128,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        let config = storage.config.read();\n\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            config.portal,\n            message_leaf_index,\n        );\n\n        // At last we mint the tokens\n        // docs:start:call_mint_on_token\n        Token::at(config.token).mint_to_private(context.msg_sender(), recipient, amount).call(\n            &mut context,\n        );\n        // docs:end:call_mint_on_token\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: u128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // docs:start:assert_token_is_same\n        let config = storage.config.read();\n\n        // Assert that user provided token address is same as seen in storage.\n        assert_eq(config.token, token, \"Token address is not the same as seen in storage\");\n        // docs:end:assert_token_is_same\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_private\n}"
    },
    "56": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "57": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "66": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "67": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "69": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "70": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "71": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "72": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "73": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "79": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "86": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "98": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    }
  }
}
