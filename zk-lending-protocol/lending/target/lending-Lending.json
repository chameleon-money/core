{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Lending",
  "functions": [
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7b3brvQ4dqX7LnXtC/FM9qs0Ngzb7W4UULAbPmxgw/C77/iXlhTxZ0iilpIhcpJfXSRWVkoRnGMMiWMOKqj/+sv/+ud//M//8/d//Zf//a///pf/8T//6y9/+9d/+of/+Ou//svj3/7rv//uL//4b3/929/++n/+/vX//sv06x9Kqa8T/v3//sO//Pr3f/+Pf/i3//jL/1AqevN3f/nnf/lfv/5Oxj4+5H//9W///Pg3/fj77fg4ue+jozbrscFvHOr0cqhz0/Njbfjv/+fvHsPRRYbj/DKcEI+HY036PtT6+D4cU2I4aVqOTiocD8evQHrt34djiwzHqmU4zmaGE6fvQ8O0QZbbHI5W0wL/YwA2ZoZjpil8H26ml8FHtXHwQ69RrbWq+PzwX3++f7ZOcflso56f7efxe+HjD8LHH5sfv/FpHX8ML+PfuJOotVarVfhjrWmcWvVUoVat1w9X9uVmtVnr4w5ml6Odes5YKk2bN+W4dVOOaa5WDVWtHqpaM1S1dqhq3VDV+qGqDUNVG4eqNo1UrRnKS5mhvJQZykuZobyUsUNVO5SXMkN5KdPbfGuXg71Tb9Xa3u7JXi/VvubbS7Xt35Odcmu1r9H2o9qvCtq/z+YqaP/emaug/fthrgIB/eK6avOowGWueuWDX4by+Ds+P3xOaK2AjrFovQLmsJL1OgFdY9F6BfSNRettzKV8jakxL/E1JtvgmGrM906vclLOh2OtPlb0FtOofznFp1b11tFhWo8OWv9RqX6oasNQ1cahqk0jVeunoapVQ1Wrh6rWDFWtHaraobyUH8pL+aG8lB/KS/mhvFQQ7aW+KhDtj74qEO15vioQ7WO+KrDiKxDtN74qEO0hvioQ7Qu+KhA91/+qILZ/L9LrQw368fd7Be1fB84uP77Sv/1Ubqmg/esgV0Fj18HXmBpzpr/GlBrzj19jquEI/fPJl0cLoY/Vd/zbs6SFj98IH79tfvzFfg+X3EC1+sq1hsm83atCg2OKDY6pxtwXtV7HFEPOUXi9ujpvXp99/PpFup4mWRWE9wqUqAqsfq9Ai6/AtF/BusOF9t79VsHWSPy0jsS/dnNuaygxrE8qxWgyR8fVJkarfjv2C0kLkoWQdCBZCEkPkoWQDCBZCMkIkoWQFOBhZSCpBHhpIUgK8PTNIOmWYUcX3pEU0Fs0g6RdNeniO5L0OFeQ9OYdyaH9pHZmQfKxxqPf0RnaI2oXwvrZyr2jM7Tvy6IztJfLoaOH9mdZdIb2XFl0hvZRWXSG9kZZdMZOfZJaVkofa9jvvZ4eO8nJoTN2OpNBx4yduOTQGTtFyaEzdjKSQ2fstCODju/tytJ22e3H6Ogy6Bgfl7cnPP5M7+j0dmWVRae3K6ssOhZ0DtDp7ZmGH6Fjzbo1nzXxPVf2veXKP0MnrV2oTfF9/cL31oVeRcdN08aV1VsXWhad3rrQouiE3rrQsugM7ZWz6AztlbPoDO2Vs+hY0DlAZ2yvnEMHr3yEDl75CB288hE6eOUDdCJe+QgdvPIROnjlI3TwykfoWNA5QAevfIQOXvkIHbzyETp45SN08MoH6CS88hE6eOUjdPDKR+jglY/QsaBzgA5e+QgdvPIROnjlI3Twykfo4JX30TES9jGriA5e+QgdvPIROnjlI3Qs6Bygg1c+QgevfIQOXvkIHbzyETp45QN0utunrCw6eOUjdPDKR+jglY/QsaBzgA5e+QgdvPIROnjlI3Twykfo4JUP0Oluz7iy6OCVj9DBKx+hg1c+QseCzgE6eOUjdPDKR+jglY/QwSsfoYNXPkCnu90Yy6KDVz5CB698hA5e+QgdCzoH6OCVj9DBKx+hg1c+QgevfIQOXvkAHYtXPkIHr3yEDl75CB288hE6FnQO0MErH6GDVz5CB698hA5e+QgdvPIBOg6vfIQOXvkIHbzyETp45SN0LOgcoINXPkIHr3yEDl75CB288hE6eOUDdDxe+QgdvPIROnjlI3TwykfoWNA5QAevfIQOXvkIHbzyETp45SN08MoH6PDevkN08MpH6OCVj9DBKx+hY0HnAB288hE6eOUjdPDKR+jglY/QwSsfoMN7+w7RwSsfoYNXPkIHr3yEjgWdA3Twykfo4JWP0MErH6GDVz5CB698gA7v7TtEB698hA5e+QgdvPIROhZ0DtDBKx+hg1c+QgevfIQOXvkIHbzyPjqW9/YdooNXPkIHr3yEDl75CB0LOgfo4JWP0MErH6GDVz5CB698hA5e+QAd3tt3iA5e+QgdvPIROnjlI3Qs6Bygg1c+QgevfIQOXvkAne7eLqZ0XEaiXA4dY1Z0jInxHZ3eZvTr6CTzjk5vM3pZdHqb0cui09uMXhad3mb0suj0NqOXRae39KssOr2lX0XR6e7tYmXRwSsfoYNXPkIHr3yEjgWdA3Twykfo4JWP0MErH6GDVz5CB698gE53bxcriw5e+QgdvPIROnjlI3Qs6Bygg1c+QgevfIQOXvkIHbzyETp45QN0unu7WFl08MpH6OCVj9DBKx+hY0HnAB288hE6eOUjdPDKR+jglY/QwSsfoNPd28XKooNXPkIHr3yEDl75CB0LOgfo4JWP0MErH6GDVz5CB698hA5e+QCd7t4uVhYdvPIROnjlI3TwykfoWNA5QAevfIQOXvkIHbzyETp45SN08MoH6HT3drGy6OCVj9DBKx+hg1c+QseCzgE6eOUjdPDKR+jglY/QwSsfoYNXPkCnu7eLlUUHr3yEDl75CB288hE6FnQO0MErH6GDVz5CB698hA5e+QgdvPI+Oq67t4uVRQevfIQOXvkIHbzyEToWdA7QwSsfoYNXPkIHr3yEDl75CB288gE63b1drCw6eOUjdPDKR+jglY/QsaBzgA5e+QgdvPIROnjlI3Twykfo4JUP0NF45SN08MpH6OCVj9DBKx+hY0HnAB288hE6eOUjdPDKR+jglY/QwSsfoMN7+w7RwSsfoYNXPkIHr3yEjgWdA3Twykfo4JWP0MErH6GDVz5CB698gA7v7TtEB698hA5e+QgdvPIROhZ0DtDBKx+hg1c+QEfY28WCzqATvPk+OAS/Hmv9XKysCfpPFitrvv2TxbY/fYawXLY6TiZTbDLRfh+d7PT8aLX10cal9Y7gpyc2avv2kablYK3U8cFKTcGtNU4pvg7kC/f2J+YD3L8qaH/yjDqtFbjpvYL2G/ro7VqB928VVHm5SPJqrSClTAWPkaSX6+A5Eq/mCqz4Cpz4Crz4CoL4CqL4ClLzFSj1nJOt+q2C96OjW8qNLxZLp9k3VXkJRL1qVWfVrr1dTNN7tXqoatv3ED+qNk3LwUnF92rtUNW2702uVqv9e7Xt+5iS1bbveUpWW8Ef6Umb9cOV0ZlebYpLZ6e1e1YQ9dZn+7ACGdSUOfhht1YcTTw+OCa/3hDeW94abyvoEMYarzXoEUYFjKdgTGkd8zTF33B8P9inaRmGTyoTgcYHwIs51F7/9x9iyhrvYIChHzFkYKhxhiwMNc6Qg6HGGfIw1DhDAYYaZ4gWunWG6M7/NEO/cEy052VwpD8vgyNddBkc6XXL4GjBsQiO9I3ncFSTnlYg7ZSxVI9VpuXJw8ciUy9PfCbs90mxmLgO2iT9ftXhkosA6Sds8hUg0zuQ+ORCQGKUCwGJUy4EpAXIMkDilQvN2iyFFAKSFYtCQNLZFAKSzqYMkIrOphCQdDaFgKSzKQSkBcgyQGLIt4D8ggaLvQsNpnkXmpFtsJ6m5zjeoRnZ2B5Do0e2qhloRjafGWhGtpMZaEaOvjPQWKDZg2ZkN5yBZmQ3nIFmZDecgQY3vAsNbngPGoMb3oUGN7wLDW54Fxrc8C40Fmj2oBl68jbPIr36IzR26NtwWDcvNS9bAC7QjHwbNnYt0kT7Bs3It+EMNCPfhjPQjBxKZKAZOZTIQDNyKJGBZmRfk4Fm5FDiGBo3cihh9fLrOmWDPT744QC/j/X++UM84zd/thfX3/hNKmUOtmb9Iaa1L+3Kr6O/GBrZlMtgaOTeQAZDI7coTTDklFmeL3LqZRraPto/wvJ1HEa982nhsys+R24Ge+Rz5A62Rz5Hbrt75HPkrKBHPkcOODrk05PK9MUnGU5ffJL49MUn+VBffFr47IpP8qG++CQf6otP8qG++CQf6otP8qGu+AzkQ6L4DGZaxhzMyxtgVz7Jh/rik3yoLz7Jh/ri08JnV3ySDwnj07iVTxfe+SQf6otP8qG++CQf6otP8iG5fL68a3XhM9J/CuMzPvlM779fifSfffFp4bMrPuk/++KT/rMvPulXZPH5HHOwxrzxOfRLx3vkk/lTFp/RLQWG6Df4ZP6szadd3+fh7MuQV4ZIZFtnCM/SOkOkprUZCqvvd3F6e04uDP0WeBkM8eRb6wzRa7XOEKsDrTNkYahxhkggWmeITKE6Q35aGdK5jEjp5NcPf8Cu3xklg+iNUTKL3hgl4+iMUUUmIotRM62LLY+//QajZCi9MUrm0hujZDTSGNX+hVGTnXeDXRHRwavc8c7FZXHp8XdK74qxKAbF/EgxZFgo5meKIVNDMT9TDJkdivmZYsgEUczPFEPmiGJ+pBhNpolifqYYMlMU8wfFTKti/DS9K4ZMtnfFGPOimNxolI3TiqCN6j3z1WS+KOZniqFXQjG/K8bFp2JCfFcMvRKK+ZFiDL0SivmZYuiVUMzPFGNRjDDFxHXQRmmdVYBafxr7+Nu6dwWwFj26AlhbHl0BrBWPrgDyjN4V4F8UEN9/tWfIJwZXgCVvGF0B5Ae9K+D564eHAvLH59ZBLL0DivldMT68JE7hXTH0GijmZ4qhN0ExP1MMvQyK+ZFiHL0PivmZYuiVUMzPFMNzqSjmZ4rhuVQU8zPFWBSDYn5TTOYJIMfzHyjmZ4oh80UxP1MMmS+K+ZliyHxRzI8U48ljhClG6ef+p8q9/47Xk5f0xih5Rm+MWhjtjFHygOqMrhtiuEfr9M4Q/XfrDNHvts4Q/WXrDPEMT+MMBZ6ZaZ0hMpHWGSLjaJ0hMovWGbIw1DhDZAqtM0SmUJuh5BbsXIrvv9AP9EOVGfLT+t5br9T7NRTph1pniH6odYboh1pniH6odYYsDDXOEP1Q6wzRDzXOUMJt12bo8d0rQ3/Yu/aLIeah1hliHmqdIeah1hniWZ/qDK1He/2HJxrfj44PNr6Pjvrl/e8qznTyYFBXdJKad0RnnDD9XdFJHt8VnYT3XdFJ0t8VnRY6e6KT7KYrOgl6RNGpvDPrZvrevRD6HQzFiWCoN0bJhnpjlHioM0YVCZE0Rp8Vehc3GKUNFcaof24F5cMU3hm1MCqL0aCfd91g/TujNKO9MUo/2huj9KO9MUo/Ko3R6J+MpvjOKP1oZ4xq+tHeGOWhhd4Y5bmF3hglM+qNUQujnTFKZiSM0ThNK6NRqXdGyYx6Y5TMqDdGyYykzaMv66NR6dzx+rnT1+Nvr3LHOxfXlNG5lN4VQyaFYn6kGEPmhWJ+phgyNRTzM8WQ2aGYnymGTBDF/EwxFsWgmB8phkwTxfxMMWSmKOYPilkTPOen6V0xZLK9K8aYF8XkRqNsnJ6vUv7j5/9SjKVXQjG/K+b4ZdrR0iuhmJ8pxqIYFPMjxdAroZifKYa1a2mKcS/PgPkNRllb7oxRx9pvb4yyNtsbo+QBvTFKv94boxZGO2OUfrc3Rlm7641R1tZ6Y5TMqDdGyYw6Y9STGQljNJqwMvqYNN8ZJTPqjVEyo94YJTPqjVELo50xSsIgjNH0fNrXJ2/fGSVh6IzRQPcijVH/vOum8P6bjIAzksVoUE9Gg0om9+lpfWDeJ/UcuNqCOvPepmDRClo5qRVWANHKWa3g/NHKWa3QU6CVs1phPRStnNUKK61o5aRWIikIWjmrFVaH0cpZrbDujFbOaoXcFq2c1YpFK2jlpFbIbdHKWa2Q26KVs1oht0UrZ7VCbotWzmqF3BatnNRKIrdFK2e1Qm6LVs5qhdwWrZzVCrktWjmrFfIVYVrRah3042/32/FfjNKtSGPUmSej8e0NBWmip2iY0S+GcPKtM4R/bp0hXGtthrQLK0Mx/Imjv/i08NkVn6za98UnnV9ffLL63RefrFCL4lNF/3w/y+Nv+84oyUxnjCqSmd4YJcnpjVGSn94YJSnqjVELo50xSlrUG6PkRb0xSmLUG6NkRr0xSmbUGaOazKg3RsmMemOUzKg3RsmMemPUwmhnjJIZCWM0KLcyGpx6Z5TMqDdGyYx6Y5TMqDdGyYw6Y9SQGfXGKJlRb4ySGfXGKJlRb4xaGO2MUTKj3hglM+qMUUv3IozROKWV0ajef6tvcUbCGE0v1+ij+Xxn1I7C6Fe1w7iGr2qHmVG/qu1shSKY9coNxr9V21l6n6m2s2T7uFrXmW/KVNtZIpqptrO0MFNtZ34xU60dqtrOvFSm2s68VKbaobyUG8pLuaG8lB/KS/mhvJQfykv5obyUt51V65/Zxctu7Eu1vXmp42p781LH1fbmpY6r7c1LHVfbm5c6rDb05qWOq+3NSx1X25uXOq62Ny91XK0dqtqhvFQYykuFobxUGMpLhaG8VBzKS8Xe5tv4zC5eHsJZqu3snhzN86kwa9+q7eyenKm2sXvy15gau3P+GlNr70P+GlNjHd3XmBrru77G1Njd+mtMtsExNdZpfI2psbnna0yNzRBfY2rwPt7aGzwfY1JTlZdQGh3WDzcxM7376fl+uefkrmL6LkBJL0BLL8BIL8BKL8BJL8BLLyBILyBKLyAJL0BJn4mV9JlYSZ+JlfSZuMoLQ4oWIH0mVtJnYtX+PGCXH5r6l19VrwXo9u9C/vnr17hRQGN3oXlQjd1Z5kE1dreYB1XjDhDMc1BRhWP9KRXdmmqoGJ6/FfVbywNhWpcHgtYvx87lhrHKjWOVm4Yqt8qGghXLVWOVq8cq14xVrh2rXDdWuWO5KjOWqzJjuSozlquyol3VXIJopzSXINr9zCWIdjRzCVZ+CaKdx1yCaDcxlyDaIcwliJ71v0pwEuaFOK0lpEkdzuRJhWXgSb08ur2UK+Hu9ZNy9WpcktbxrVwJd7qC5Uq4KxYst7E76Dyoxu6J86Aa61e+BlVl65ro118/6KQ3BqVaHJRucVCmxUHZFgflWhyUb3FQocVBxRYHlRocVGjxjh5avKPX2I7iccj6q07zsMbHTs3otDxmZIyyf/ReNXaYKFuAlV6Aa74As14FxvzWi74fa9VarNXqrW+tsQ1EvWJD7WK9f79jxSqDss9BhfdHtWrsqfAYSHgOKoU/dRHX2CahbAFKegG6+QLK3VmiGalYO1KxrnKxjyG83Z5jnVnbvAwqvQ+qxuxq1XMis8EcyyLzgH+NLTrKFpCEF1Bj84+yBSjpBWjpBRjpBVjpBTjpBXjpBUifiZP0mTgJn4nVJHwmVpPwmVhNwmdiNQmfidXU/l3o8Ae/SrV/DRz+4FfV2DfBeLd+uHl9Znt7i8iwtuqPP//4JI2qsW9C2QKs9AKc9AK89AKC9AJi6wUo9xjkcrhTRr2VkMSXoCf5JSj5JTQ/I+dLaH5GUE6b9XCnrX4rQcAdST83dn/8nd5KaOyO9DUo09g9Zh5UY3eNeVA17gNxWh9xN9H690GZFgdlWxyUa3FQvsVBhRYHFVscVGpwUDV+YZ0flGpxUC3e0W2Ld/Qav1Q2ya9PX9jp5edd2w2tTov50mZ6PtOikvkuwckvwcsvIcgvIYoqQemNEpL4EtwkvwTVfAkmxLWE5H4rYStTPNr55dESj1WuGatcO1a57buJouW27zyKltu+SylabvuOpmi57bufkuX69p1S0XLHclV+LFflx3JVNfagqFmuaFc1lyDaKc0liHY/cwmiHc1cgmiX8lVCEO085hJEu4m5BNEOYS5B9Kw/l9D+TG7Vsgj0GMm0UUL7s3O2hPZn52wJ7c/O2RLan52zJbQ/O+dKiO3PztkS2p+dsyW0PztnS2h/ds6WIH92jvJn5yh/do7yZ+cof3aO8mfnJH92TvJn5yR/dk7yZ+cq+4MULkH+7Jzkz85J/uyc5M/OSfzsrCfxs7OexM/OehI/O+tJ/OysJ/Gzs57Ez856Ej8760n87Kwn8bOznuTPzkr+7Kzkz85K/uys5M/OVXYzKlyC/NlZyZ+dlfzZWcmfnZX82VnLn521/NlZy5+dtfzZWcufnbX82VnLn521/NlZy5+dtfzZ2cifnY382dnIn52N/Nm5yj5mhUuQPzsb+bOzkT87G/mzs5E/O1v5s7OVPztb+bOzlT87C9iTLluC/NlZwJ502RLkz84C9qTLliB/dhawJ122BPmzs4B95rIlyJ+dBewHly1B/uwsYN+2bAnyZ2cB+6tlS5A/OwvYBy1bgvzZWcB+ZdkS5M/OAvYVy5Ygf3YWsFdYtgT5s7OAvcKyJcifnQXsFZYtQf7sLGCvsGwJ8mdn+XuFaQF7hTnrlhKcV+8lCNgfKVtC89eCmYJePzuajRKavxbyJXz6Wpi/xd/yLeGWbyljyZ43KWPddEy6desrVK17fYf7MqTU3JAKbRFTdEiqvSHp9oZk7h9S0stNyiaTjg82Oi3jN0Y9L0//PXwre/hO9vB948M3Pq3Dj+Fl+BsfrNZSrVbhrdQwTqn3z3jOueVg53z4c6JMkodvpkn28FXjwy92nZhJj1OqqVBqWny583r6o3Exk21vSK69IfkaQ/LPIYX3IYX2hhTbG1JqbkiqxsyU3DokszGkCrON93odUjLvQ9LtDcnUGNLywlkXpo0hVbh7Bx3XISV1fLCywS4Dceo1SJs2jvbT8sleP19YrmL6LtaNVKwfqdgwUrFxpGLTQMXqaaRi1UjF6pGKNSMVa0cqdiQHpUdyUHokB6VHclB6JAdlRnJQhfYiaaVYuxzsndootq8b1JoUeR83im39BuWUW4t9eVjnV7FzAa3fdHIF2NZvJNkCWm+vsgU03zJZ9SzAZS545YNfVogef8fnSL6X9mzzTVPZcpufu8qW23zjVLbc5lunsuV+2pvM3xJv+ZZ0x7cU2hbD+ue3BP/+LWXmwBiXR79NMjllPd/5/rLcpkPaODZOi2OML4+VbR+b4jLklH4/dq5UD1OpGaZSO0ylbphK/TCVhmEqjcNUmkaptNDGIBIqHcYj+WE8UqHdSJJdf/eglDuuNOqk1uFP/vjggk9EF9q1REKpoZB3cMvhj/Hot54ppA8D+vUthX5InfsWdcu36Fu+xdzyLfaWb3G3fIu/5VvCLd8Sb/mWW679dMu1n2659tMt13665dpPt1z76ZZrP91y7adbrv10y7Wf7rj27TTd8i3qlm/Rt3yLueVb7C3f4m75Fn/Lt4RbviXe8i23XPvqlmtf3XLtq1uufXXLta9uufbVLde+uuXaV7dc++qWa1/dcu3rW659fcu1r2+59vUt176+5drXt1z7+pZrX99y7etbrn19y7Vvbrn2zS3Xvrnl2je3XPvmlmvf3HLtm1uufXPLtW9uufbNLde+veXat7dc+/aWa9/ecu3bW659e8u1b2+59u0t17695dq3t1z77pZr391y7btbrn13y7Xvbrn23S3Xvrvl2ne3XPvulmvf3XLt+1uufX/Lte9vufb9Lde+v+Xa97dc+/6Wa9/fcu37W659f8u1H2659sMt13645doPt1z74ZZrP9xy7Ydbrv1wy7Ufbrn2b3muz97yXJ+95bk+e8tzffaW5/rsLc/12Vue67O3PNdnb3muz97yXJ+95bk+e8tzffaW5/rsLc/12Vue67O3PNdnb3muz97yXJ+95bk+e8tzffaW5/rcLc/1uVue63O3PNfnbnmuz032lm9xt3xLkWvfqrDs5fBYmc68uqHcb7JcmecFq40+ih59kjz6Ms9NVhu9Ej16LXr0RvTorejRO9GjFz3XKtFzrRI91yrRc61ufK716x6j06Q3ht/4ZJsbfuOzbW74jU+3ueE3Pt/mht/4hJsbfqH9kg53d3CFnivPfUu641sKPVee+xZ1y7foW77F3PIt9pZvcbd8i7/lW2659s0t17655dq3t1z79pZr395y7dtbrn17y7Vvb7n27S3Xvr3l2re3XPv2lmvf3XLtu1uufXfLte9uufbdLde+u+Xad7dc++6Wa9/dcu27W659f8u172+59v0t176/5dr3t1z7/pZr399y7ftbrn1/y7Xvb7n2wy3Xfrjl2g+3XPvhlms/3HLth1uu/Vv2WHXhlms/3HLth1uu/XjLtR9vufbjLdd+vOXaj7dc+/GWaz/ecu3HW679eMu1H2+59tMt13665dpPt1z76ZZrP91y7adbrv10y7Wfbrn20y3Xfrrj2vfTdMu3qFu+paP3TxwvZvupo5d05Uq145Ta0Wu6cqV29J6uXKkdvagrV+qnf3G1MfwfvSxGry+AMUbZ9WD/Pfwkevgf3//5w8NX9w/fpOXgaLXOXFQ/ewH9tNTq9ROX5QX0/uP7WzdVrBmpWDtSsW6kYv1IxYaRio0jFZsGKlZPIxU7koPSIzkoPZKD+vg7E5oqdiQHpUdyUHokB6VHclB6JAdlRnJQZiQHZUZyUGYkB/XxN880VexIDsqM5KDMSA7KjOSgbF/zrF0O9k5tFNvX3dgvn+x93Ci29buxU24t1tjfip0LaP0Omy2g9btmtoDW74TZAprvD616FuAyF7zywS9btjz+jtN6/PfCvWu+QyxbbvNzV9lym+8Sy5bbfJ9YtlzbUrnzkJpyEPOQmvIE85AqzPLWLfNedDFzsAp+1WnwzwcLvducUddP/vUQ4fHBca0w2ufnKuu+gYkAsw1MAphNYPwEMNvAKIDZBkYDzDYwZlhgnqMI/jdg3o/V0zq3/0JmPdr6rQ9en/tPSuc+2KQFZ22nJxbGfNu9j7+eEn7+HD8Ofprmx8NP0/x02xXp3/iZi+2209kqttvuZaPY0HhHoqdpKVZPLytGm8XaaUXGTsm/F9t4l1G22NY7h7Qu7+nJhFyx61buOnfrfiwQrr/ef/ztn0mkTvYbm9abh5rYWLDZxaZ101wTm9YNa01sWjeLNbFp3VvWxKZ1K1oRm9h6ll4Tm9bj9JrY4Iv3scEX72NjwWYXG3zxPjb44n1s8MX72OCL97HBF+9ik/DF+9jgi/exwRfvY4Mv3sfGgs0uNvjifWzwxfvY4Iv3scEX72ODL97DJkz44n1s8MX72OCL97HBF+9jY8FmFxt88T42+OJ9bPDF+9jgi/exwRfvYqPwxfvY4Iv3scEX72ODL97HxoLNLjb44n1s8MX72OCL97HBF+9jgy/exUbji/exwRfvY4Mv3scGX7yPjQWbXWzwxfvY4Iv3scEX72Mzhi+eax3D537VasbwrXOtXflQMy2jCHGj1q58ZabWxn2iVmoZv1bvu6qEGm9FKTr+xv1WdvyNe6Ls+Bv3LVqZ5aUbWk+2oG8x64vb1WPM69HLtlvBNO5aKiLTuMeph4xtfY+resi0viFWPWQad1sVkWnem1VDxoLMDjLN+8kiyMy1Nu89C9Y6hk+da+3KeR7337YrL3lca/svWSr3gsDQ/iuWflRsWCTjXxTzLLavF/EGtRbrN4q1IxXb14t4M8X29SLeTLF9vYg3U2xfL+LNFNv8qyoLFuubf1FluRfxBt+Xg8oU25eDyhTbl4PKFGtHKrYvB5Upti8HlSm2LweVKbYvB5Upti8HdVxsGMlBhZEcVKEXjFi/xHrGvrwnLKrvb3G3fIu/5VvCLd8Sb/mWdMe3FHo5QO5b1C3fom/5FnPLt9xy7cdbrv14y7Ufb7n24y3Xfrzl2k+3XPvplms/3XLtp1uu/XTLtZ9uufbTLdd+uuXaT7dc++mOaz9O0y3fom75Fn3Lt5hbvsXe8i3ulm/xt3xLuOVb4i3fcsu1r2659tUt17665dpXt1z76pZrX91y7atbrn11y7Wvbrn21S3Xvr7l2te3XPv6lmtf33Lt61uufX3Lta9vufb1Lde+vuXa17dc++aWa9/ccu2bW679Qj+vtXF5YNo4Hf77eAUhrA/sTs/1Ax3S1tLEtCw2PBYpMsemuAw5pd+PnSu1w1TqhqnU91OpX5fVpklvlBrGKTWOU2oaptRCP70VUaoap9QyLsWtP+IxD6Ecl+rtup+R98nncHHLEwi/nppZD94sVodp3bckvDwI4b9rNQPVageq1Q1Uqx+o1jBQrXGgWtM4tbppoFrVQLUO5JvcQL6p0G9vZdQ6kG9yA/kmN5BvcgP5JjeQb/ID+SY/kG/ycn3TPH65XmgevxU+frmeZR6/XB8yj1+ut5jHL9cvzOOX6wG+xh/kzuvz+OXO1fP4hc+/Qfj8W+gXs/XGL3z+DcLn3yB8/g3C598gfP6NwuffKHz+jcLn3yh8/i30q/V64xc+/0bh828UPv9G4fNvFD7/JuHzbxI+/ybh828SPv8W2jmi3viFz79J+PybhM+/Sfj8m2TPv2mSPf+mSfb8mybZ82+aZM+/aZI9/6ZJ9vybJtnzb5pkz79pkj3/pkn4/KuEz79K+PyrhM+/Svj8W2gHpXrjFz7/KuHzrxI+/yrh868SPv9q4fOvFj7/auHzrxY+/xbaxaze+IXPv1r4/KuFz79a+Pyrhc+/Rvj8a4TPv0b4/GuEz7+FdvGrN37h868RPv8a4fOvET7/GuHzrxU+/1rh86/g/ebm8QuffwXvCzePX/j8K3j/tnn8wudfwfuszeMXPv8K3g9tHr/w+VfwvmXz+IXPv4L3F5vHL3z+FbwP2Dx+4fOv4P265vELn38F76s1j1/4/Ct8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6skfP+rJHz/qyR8/6ske/8rPcne/+oxftHz72P8ouffx/hFz7+P8Yuefx/jFz3/PsYvev59jF/0/PsYv+j59zF+4fOv7P2vHuMXPv/K3v/qMX7h86/s/a8e4xc+/8re/+oxfuHzr+z9rx7jFz7/yt7/6jF+4fOv7P2vHuMXPv/K3v/qMX7h86/s/a8e4xc+/8re/+oxfuHzr+z9rx7jFz7/yt7/6jF+4fOv7P2vHuMXPv/K3v/qMX7h86/s/a8e4xc+/8re/+oxfuHzr+z9rx7jFz7/yt7/6jF+4fOv7P2vHuMXPv82v/9VmqZlIMlsjL/5+TesA0lpeh3/+8Fxst/HxpdS9eaxKS6fm9Lvx37h0v6+WpVwad4vVMKleR9SCZfm/U0lXCy4bOLSvB+rhEvzPq8SLs37x0q4NJ8LVcIFv7uJS/v72FXCBb+7jQt+dxsX/O42LhZcNnHB727jgt/dxmVYv+uXY9U06Q1ghjW8OWCGdbwZYNrfOrIWMMN63hwww5reHDByXe88fit8/HJd5Dx+uW5vHr9cVzaPX655mscv1+N8jb/9XTQz45frGObxy53Y5/ELn3/b30UzM/7G51+tQvo+2Ibkjo2hXUdhvX0OOcatD34+XmSUyjhOP62f7B+W8Tc0ZhgbtwGNwOjs4sa9C9MGjI27ESkwNm6KpMDYuDcTAmPrG71KgbFxpyoFxsYNsxQYG/ftUmC0wFgCRrqYIjDSxRSBkS6mCIx0MUVgpIspAKNqfbtsKTDSxRSBkS6mCIx0MUVgtMBYAka6mCIw0sUUgZEupgiMdDFFYKSLKQFj6y8dkAIjXUwRGOliisBIF1MERguMJWCkiykCI11MERjpYorASBdTBEa6mBIwtv7qFikw0sUUgZEupgiMdDFFYLTAWAJGupgiMNLFFIGRLqYIjHQxRWCkiykBY+svwJICI11MERjpYorASBdTBEYLjCVgpIspAiNdTBEY6WKKwEgXUwRGupgSMLb+GkEpMNLFFIGRLqYIjHQxRWC0wFgCRrqYIjDSxRSBkS6mCIx0MUVgpIspAWPrL02VAiNdTBEY6WKKwEgXUwRGC4wlYKSLKQIjXUwRGOliisBIF1MERrqYEjC2/ipcKTDSxRSBkS6mCIx0MUVgtMBYAka6mCIw0sUUgZEupgiMdDFFYKSLKQFj6283lgIjXUwRGOliisBIF1MERguMJWCkiykCI11MERjpYorASBdTBEa6mBIwtv5idCkw0sUUgZEupgiMdDFFYLTAWAJGupgiMNLFFIGRLqYIjHQxRWCkiykBY6KLKQIjXUwRGOliisBIF1MERguMJWCkiykCI11MERjpYorASBdTBEa6mAIw6okupgiMdDFFYKSLKQIjXUwRGC0wloCRLqYIjHQxRWCkiykCI11MERjpYkrAqOhiisBIF1MERrqYIjDSxRSB0QJjCRjpYorASBdTBEa6mCIw0sUUgZEupgSMmi6mCIx0MUVgpIspAiNdTBEYLTCWgJEupgiMdDFFYKSLKQIjXUwRGOliSsBo6GKKwEgXUwRGupgiMNLFFIHRAmMJGOliisBIF1MERrqYIjDSxRSBkS6mBIyWLqYIjHQxRWCkiykCI11MERgtMJaAkS6mCIx0MUVgpIspAiNdTBEY6WJKwOjoYorASBdTBEa6mCIw0sUUgdECYwkY6WKKwEgXUwRGupgiMNLFFIGRLqYEjJ4upgiMdDFFYKSLKQIjXUwRGC0wloCRLqYIjHQxRWCkiykCI11MERjpYkrAGOhiisBIF1MERrqYIjDSxRSB0QJjCRjpYorASBdTBEa6mCIw0sUUgZEupgSMkS6mCIx0MUVgpIspAiNdTBEYLTCWgJEupgiMdDFFYKSLOQNjCGYZctQ5NHxQ68H+ZRjpG3I6ntshpzu6G/JEJ3U75HRdJyB3Kbkn5CmDxmOgS4E2mid2Om0drbwKC9TePIdtjPumiI6ueYroFpunyEJRnqLgwjLk4O2UQ8Po5ZOtezl2i3u/YvHoKV4ONttjTusnT1P87eiZTRrintikL++JTeKBntgkeeiJTUKNfth8/J+w2RGbRDE9sUlq0xObBDw9sWlhsyM2yYJ6YpMsqCc2yYJ6YpMsqCc2yYI6YlORBfXEJllQT2ySBfXEJllQT2xa2OyITbKgntgkC+qJTbKgntgkC+qJTbKgjtjUZEE9sUkW1BObZEE9sUkW1BObFjY7YpMsqCc2yYJ6YpMsqCc2yYJ6YpMsqCM2DVlQT2ySBfXEJllQT2ySBfXEpoXNjtgkC+qJTbKgntgkC+qJTbKgntgkC+qITUsW1BObZEE9sUkW1BObZEE9sWlhsyM2yYJ6YpMsqCc2yYJ6YpMsqCc2yYI6YtORBfXEJllQT2ySBfXEJllQT2xa2OyITbKgntgkC+qJTbKgntgkC+qJTbKgjtj0ZEE9sUkW1BObZEE9sUkW1BObFjY7YpMsqCc2yYJ6YpMsqCc2yYJ6YpMsqCM2A1lQT2ySBfXEJllQT2ySBfXEpoXNjtgkC+qJTbKgntgkC+qJTbKgntgkC+qIzUgW1BObZEE9sUkW1BObZEE9sWlhsyM2yYJ6YpMsqCc2yYJ6YpMsqCc2yYI6YjORBfXEJllQT2ySBfXEJllQT2xa2OyITbKgntgkC+qJTbKgntgkC+qJTbKgfti0E1lQT2ySBfXEJllQT2ySBfXEpoXNjtgkC+qJTbKgntgkC+qJTbKgntgkC+qITUUW1BObZEE9sUkW1BObZEE9sWlhsyM2yYJ6YpMsqCc2yYJ6YpMsqCc2yYI6YlOTBfXEJllQT2ySBfXEJllQT2xa2OyITbKgntgkC+qJTbKgntgkC+qJTbKgjtg0ZEE9sUkW1BObZEE9sUkW1BObFjY7YpMsqCc2yYJ6YpMsqCc2yYJ6YpMsqCM2LVlQT2ySBfXEJllQT2ySBfXEpoXNjtgkC+qJTbKgntgkC+qJTbKgntgkC+qITUcW1BObZEEn2HQpuYXN6EwOjajNioZ7frRJ08bRyurls5UNTzjUJv1Gheew4/No7TePnoxaj3bhOZLJbxwdlV9GEvWUnp8dt8Ztw2RWZn6Ndflsp7+lRTCFtD4kLVIypPUhaVmkhbQ+Iy3yQ6T1IWkRZiKtD0mLZBVpfUhaxLxI60PSInNGWp+RlicAR1ofkhZpPNL6kLRI45HWh6RFGo+0PiQti7SQ1mekRRqPtD4kLdJ4WdKy04KHsUFnpGWNWp6psiao52f7b/YJzEdmn0x7ZPaJnQdmP5AMj8w+4e3I7JOvjsw+EejI7FvYH5h9gsSR2SfrG5l9sr6R2Sfre2N/BoYYbBuYSEK0AwzhyQ4w5Ao7wNBy7wBjAWYbGBq1HWDoYXaAwd7vAIPz3QEG57sNTML57gCD890BBue7AwzOdwcYCzDbwOB8d4DB+e4Ag/PdAQbnuwMMzncTGDfhfHeAwfnuAIPz3QEG57sDjAWYbWBwvjvA4Hx3gMH57gCD890BBue7DYzC+e4Ag/PdAQbnuwMMzncHGAsw28DgfHeAwfnuAIPz3QEG57sDDM53GxiN890BBue7AwzOdwcYnO8OMBZgtoHB+e4Ag/PdAQbnuwMMzncHGJzvNjAG57sDDM53Bxic7w4wON8dYCzAbAOD890BBue7AwzOdwcYnO8OMDjfbWAszncHGJzvDjA43x1gcL47wFiA2QYG57sDDM53Bxic7w4wON8dYHC+28A4nO8OMDjfHWBwvjvA4Hx3gLEAsw0MzncHGJzvDjA43x1gcL47wOB8t4HxON8dYHC+O8DgfHeAwfnuAGMBZhsYnO8OMDjfHWBwvjvA4Hx3gMH5bgPDu073gMH57gCD890BBue7A4wFmG1gcL47wOB8d4DB+e4Ag/PdAQbnuw0M73DbAwbnuwMMzncHGJzvDjAWYLaBwfnuAIPz3QEG57sDDM53Bxic7zYwvMNtDxic7w4wON8dYHC+O8BYgNkGBue7AwzOdwcYnO8OMDjfHWBwvpvA+L5e8aFWYHT4DZivWgW/g2Eev1xrNY/fCh+/XKMyj1+un5jHL3fan8cvd3aexy93rvgav+C96+fxyw1j5vELn38Fb9g+j1/4/Ct4+/N5/MLnX8Gbic/jFz7/Ct6a+2v8gnfQnscvfP4VvB/1PH7h86/g3Z3n8QuffwXvlTyPX/j8K3jn4Xn8wudfwfv4zuMXPv8K3hV3Hr/w+VfwHrPz+IXPv4J3bJ3HL3z+Fbz/6Tx+4fOv4N1E5/ELn38F7805j1/4/Ct4p8t5/MLnX8H7Rs7jFz7/Ct6FcR6/8PlX8J6G8/iFz7+Cdwicxy98/hW83948fuHzr+Dd6+bxC59/Be8FN49f+PwreGe1efzC51/B+5TN4xc+/wre9Wsev/D5V/AeWvP4hc+/gnekmscvfP4VvL/TPH7h82/ruyXZGPQy/jSZ9/E3Pv/aOD3Hr9Tr+N8PjpP9PjaatB6qN49NcRlESr8fO+PS+LxeDZfG/UI1XBr3IdVwadzfVMOlcd9UDZfG/VgtXFrfzagaLo37x2q4NO9LK+GC393GxYLLJi743W1c8LvbuAzrd/1yrJomvQHMsIY3B8ywjvcYmDANa3lzwAzreXPADGt6c8A05XrnIdn2htSU15uH1JTNmofUlMOZh9SUt5iH1NSs/jUk1dR8Og+pqZlsHlJTc8g8pPbu3m1t+zcPqb27d1ub881Dau/u3dYWevOQ2rt7t7XR3Tyk9u7ebW1HNw+pvbt3W5vGzUNq7+7d1tZu85Dau3u3tQHbPKT27t5tbZM2D6m9u3dbm5nNQ2rv7t3WlmPzkNq7e7e1Mdg8pPbu3m1t3zUPqb27d1ubbM1Dau/u3dZWWPOQ2rt7t7Vh1Tyk9u7ebW0rNQ+pvbt3W5s/zUNq7+7d1hZN85Dau3u3tZHSPKT27t5tbXc0D6m9u3dbmxLNQ2rv7t3W1kHzkNq7e7e1wc88pPbu3m1twzMPqb27d1ub5cxDau/u3daWNvOQ2rt7t7XxzDyk9u7ebW0PMw+pvbt3W5u4zENq7+7d1lYr85Dau3u3tSHKPKT27t5tbVsyD6m9u3dbm4vMQ2rv7t3WFiDzkNq7e7e1ocY8pPbu3m1tIzEPqb27d1ubJ8xDqnD3DpNZhhR15uByP3EMNbYiqFWqGqdU3VGpmZ9D1dgEoFqtdqBa3UC1+oFqDQPVGluqdR5SU97m15Di1JQHmYdUYVKJOnwf/Fi6C8cHW7V8sNXPQ1WM38OPsoefRA+/xm8zSw5fNT58Oy3Dd78Pf6vU9KxVPY/236XqcUpt/Y5WsFQ7TqlunFL9OKWGcUpt3akULLV1V1OuVN26AypY6jhuSY/jlvQ4bqnG78drlTqOW9LjuCU9jlvS47glPY5bMuO4JTOOWzLjuCUzjluqsV9DrVJbd0vrB1tvM6UefPBca+t2qWStrfulkrW2bph+UGtQwa0frPXxB6tHMPF9sJ6m56vulPte5TGt+6tqyNjW7VgZZOZaW/djJWtt3ZDt1joPX+7Lfbesx+ESdFs7hny4VrkvDf55rXJfMPzzWuW+jPjHtba1K8uHa5X7kuOf19r4Ozh+Vmu51ritzWwawsWCyyYuXXm3grh05fMK4tKVJyyIS1f+sSAuXXnNH/T8mR9gxLY2nGoJmK5cbElgurK8JYHpyvOWBMYCzDYwXbneksB0ZXtLAtOV7y0JTFfGtyQwON9tYNrarK8lYHC+O8DgfHeAwfnuAGMBZhsYnO8OMDjfHWBwvjvA4Hx3gMH5bgPT1kanLQGD890BBue7AwzOdwcYCzDbwOB8d4DB+e4Ag/PdAQbnuwMMzncbmITz3QEG57sDzKjOVzu7fLB2KR5/sErrkFX6Nc4Fxjh9wziqT/4ZjA+cloMn8zuM70dH5Zefc0U9pczRNk7LL63s64auxulviiwUtU7RqL2DIIpG7WIEUTRqPyWIolE7O0EUjdpjiqEoTaN2u4IoGrXvFkQRCUDzFJEuNE+RhaI7KZpBJy+oADoJQAXQ6enLg67VE3SnM0eHZNfNxVIymaPNip19mS02SdEqLUs0Wiv9evBMPVnBsNSTQYxKvSLbGJZ6MpNhqSeLGZZ6Mp5hqbdQPyr1JFjDUk+ONiz1pHnDUk+aNyz1pHmjUq9J84alnjRvWOpJ84alnjRvWOot1I9KPWnesNST5g1LPWnesNST5g1LPWneqNQb0rxhqSfNG5Z60rxhqSfNG5Z6C/WjUk9f3y312jypt+6NeovD75b6oNYKgzHv1OPwh6Uehz8s9Tj8Yam3UD8q9azXD0s96/XDUk9fPyz1rNcPSz3r9aNS74ad69M0LUNWajr+YO/skol6F6bf0JhhHHbeLAvjsHNQWRiHvZ8XhdEPu9JRFsZhVw3KwjhsAl8WxmHT7LIwWmAsAeOwKWtZGOliisBIF1MERrqYIjDSxZSAMdDFFIGRLqYIjHQxRWCkiykCowXGEjDSxRSBkS6mCIx0MUVgpIspAiNdTAkYI11MERjpYorASBdzAkaX0vJQi09qC0a6mCIwWmAsASNdTBEY6WKKwEgXUwRGupgiMNLFlIAx0cUUgZEupgiMdDEnYAwuLEMO3k45NIxePvll74xfO6i88+NXLB5N5svBZnvMaf3kaYq/HT2zyUwnh00zpQUMo1Xu6LCMIoT1SBu+aWdmHo/2xx0AJzEk7TifIWnHqQ1JO/n4kLRbaB+RdtYfhqSd9ZIhaWd9Z0jaSemGpJ2UbkTaFSndkLST0g1JOyndkLST0g1Ju4X2EWknpRuSdlK6IWknpRuRdk0Dd4Z2o6cVQ2syaKgHgQt4wafn0XarQjctey27V0E9jp0JotVqnCCaosYJshDUNkE0Go0TREvQOEGY98YJYjG8cYJYtm6bIMMCc+MEkSTUJsgve/m8vuFp+1ir3cKm1dH+liDNdOL5KtMZ14NjMJljtdHLwQ9W1Hr0zhu7lH++sWtKmaNtnMKCXnx5C5dx+lsquE+kclIq+GCkclIqOHKkck4qlt4AqZyUCl0KUjkpFVZekcpJqbAGjFROSsUiFaRyTiqsiyOVk1IhrUUqJ6VCWjukVGbyyV8HJp9EdVzyHRlpv+Rr9ST/Mc8fHx2SXY4OKZnM0Wbl0L64iU04tErLAwhaK/168CxBslckWFmCZLpIsLIEyYqRYGUJWiSIBOtKkGwbCVaWIJk5EqwsQbJ4JFhZgqwIIMHKEmRdAgnWlaBndQQJVpYgqyNIsLIEWR1BgpUlyOoIEqwsQYsEkWBdCbI6ggQrS5DVESRYWYKsjiDByhJkdQQJVpYgqyNIsK4EA6sjSLCyBFkdQYKVJcjqCBKsLEFWR5BgZQlaJIgE60qQ1REkWFmCrI4gwcoSZHUECdaVYCQXRIIflqA2Twm+vER5lSAdMRL8sASDWijUwZh3CVokiATrSpCOGAlWliAdMRKsLEE6YiRYWYI8L4gEK0uQ5wWRYF0JJnJBJFhZgjwviAQrS5DnBZFgZQmyOlJZgkmr74OTc5lj3RSWtS6nppdxmPhNp4XOnugkte+KThLwrugkTa5t36JZDp4mn/NvzxdgaW1Czr+VfadiIvZFK2e1Qj6LVs5p5TE8tIJWTmqFxBOtnNUK0SRaOasVMkS0clYrFq2glZNaIf1EK2e1QrSKVs5qhdwWrZzVCrntmFqZ2SeJHZh9RbY6MvukpR2zL2L7DKVIYdFgbQ2S7qLB2hq0aBANVtYgaTQarK1BUm40WFuDpOdosLYGSeXRYG0NsjaABitrULNCgQZra5B1EjRYW4Osk6DB2hpknQQN1tagRYNosLIGWSdBg7U1yDoJGqytQdZJ0GBtDbJOggZra5B1EjRYWYOGdRI0WFuDrJOgwdoaZJ0EDdbWIOskaLC2Bi0aRIOVNcg6CRqsrUHWSdBgbQ2yToIGa2uQdRI0WFmDlnwQDX5ag9o8NWjduwYtGkSDH9bg8RsJlaUvRoO1NUhfjAZra5C+GA3W1iB9MRqsrUGeH0SDlTXoeH4QDdbWIPkgGqytQZ4fRIO1Ncjzg2iwtgbJB8tr0Gu7ajBkZZWmdSUrOZM52k7TIlk72Rd9mzgT6jFXlQk106SWgUwxS7/R613F/jri+K5S9p1gHheEWE6LBbuCWE6LxSIWxHJWLDwogVhOi4WOBbGcFguPHiCW02LhGQHEclosLOYjlrNiCay6I5bTYiHBRSynxUKCO6hYZvrJZIem30L/yPSTm/ZMv4xfewfyWERYXYTkvIiwugjJjxFhdRGSSyPC2iKM5N2IsLoIydERYXURks8jwuoiZJUAEVYXoUWEiLC2CFkxQYTVRciKCSKsLkJWTBBhdRGyYoIIq4uQFRNEWFuEiRUTRFhdhKyYIMLqImTFBBFWFyErJoiwuggtIkSEtUXIigkirC5CVkwQYXURsmKCCKuLkBUTRFhdhKyYIMLKItQTKyaIsLoIWTFBhNVFyIoJIqwuQnJCRPhxEWrzFKF17yKkO0aEHxfh8Su19ER3jAhri1DRHSPC6iKkO0aE1UVId4wIq4uQ5wkRYXURWkSICGuLkJwQEVYXIc8TIsLqIuR5QkRYXYSsmNQWoZpW7JQLmaMfIKzcvyKtTPwmlNWHvgjVJPmdEUoq3hmhJMzVCQ0rdlrnCNXP92ppbULOyBV9YePjCxELYjkrFotYEMtZsZCsIpbTYiEBRSynxUJSiVhOi4VEEbGcFgtpJWI5KxZDEopYTouFlBWxnBYLCS5iOS0WEtxBxTLTb6F/ZPpJWYemn9y0Z/pl7LVhyGMRYXURkvMiwuoiJD9GhLVFaMmlEWF1EZJ3I8LqIiRHR4TVRUg+jwiri9AiQkRYW4SsVSDC6iJkxQQRVhchKyaIsLoIWTFBhNVFyIoJIqwtQseKCSKsLkJWTBBhdRGyYoIIq4uQFRNEWF2EFhEiwtoiZMUEEVYXISsmiLC6CFkxQYTVRciKCSKsLkJWTBBhbRF6VkwQYXURsmKCCKuLkBUTRFhdhKyYIMLqIiQnRIQfF6E2TxFa9y5CumNE+HERZt5iGOiOEWF1EdIdI8LqIqQ7RoTVRUh3jAiri9AiQkRYW4Q8T4gIq4uQnBARVhchzxMiwuoi5HlCRFhbhJGc8IQIXUorPdHlRGiiNisa7vnRJm2RqYxZXvGkzC8Mls/+tci6UeKibxufaCjnvukkceuKTrKrrui00NkTneQpXdFJMtEVnfT4ouh0K3bOb9FJt9wVnTypJ4vOsIzahfROZ+KZt67oJBWSRef6bL6fzAadpEJd0UkqJJVOpTbotNDZE52kQqLo9EEt2MVpg05Soa7oJBWSRWdcBuKT3aCTVKgrOkmFRNEZpgWOoOIbnWYiFeqKTlIhqXRqv0EnqVBXdJIKdUWnhU5RdK4DiZPdoJNUqCs6SYVE0RnXm23cdLakQl3RSSoki06zfHS0eoNOUqGe6FSkQlLpdNMGnaRCXdFJKiSKzqSWg9NWjKBIhbqi00KnKDrN8jRCsmqDTlKhrugkFZJF54pd8ls3W1KhrugkFZJKZ9iI4BWpUE90alIhUXSqyS3DflC0ESRocqHOCCUZqk2o1ctnK/u6u9kmoQ//+hx2fB6t/ebRU1h+1vJYP3uy+Fjq3jo6qHXc4XXcj6NnsZA7IZbTYrGIBbGcFQuZGWI5LRYSOcRyWizkfYjltFhIExHLabGQVSKWs2IxJKGI5bRYSFkRy2mxkOAiltNiIcFFLKfFYhELYjkrFhJcxHJaLCS4iOW0WEhwEctpsZDgIpbTYiHBRSxnxWJJcBHLabGQ4CKW02IhwUUsp8VCgotYTovFIhbEclYsJLiI5bRYSHARy2mxkOAiltNiIcFFLKfFQoKLWM6KxZHgIpbTYiHB7Vos66ZfRrmQEUtUft04Xk/PVyvruDVuGyazMqOee+Uap7+lRd6LtD4kLdJhpPUhaVmkhbQ+Iy2SZ6T1IWmRUyOtD0mL7AlpXZTWisnjT/8uLU+HiLSuSStOy/aQ9nH4hrToEJHWCWnNYrGIBbGcFQtdHGI5LRb6MsSyiEWrp1iczjickOyKSUomc7RZObcvbmgTPq3SsoCo9UvD9zh4lixPMSFZYZLlWSokK0yypGpIVpZkA8+VIVlhkuXpNiQrTLKsiSBZYZJlrQXJCpOsRbJIVpZkWXdCssIky+oXkhUmWVa/kKwwybL6hWSFSZbVLyQrS7KR1S8kK0yyrH4hWWGSZfULyQqTLKtfSFaYZC2SRbKyJMvqF5IVJllWv5CsMMmy+oVkhUmW1S8kK0yyrH4hWVmSTax+IVlhkmX1C8kKkyyrX0hWmGRZ/UKywiRLLotkG5OsNk/JWvcuWRIDJNuYZINaKNfBmD9K1k4kBkhWmGRJDJCsMMmSGCBZYZIlMUCywiRrkSySlSVZnpdFssIkSy6LZIVJludlkawwyfK8LJIVJllWv2RJ9gHI8tkmxIxky7740SrWnRDLabGw4oNYTouFtRbEclosrHIgltNisYgFsZwVC8k+YjktFjJ1xHJaLKTZiOW0WMiREctpsZDgIpazYtEkuIOKZaafTHZo+klZh6af3LRn+kX8QtxqiwgRYW0RkvMiwuoiJD9GhNVFSC6NCKuLkLwbEVYXITk6IqwtQkM+jwiri5BVAkRYXYSsVSDC6iJkxQQRVhehRYSIsLYIWTFBhNVFyIoJIqwuQlZMEGF1EbJiggiri5AVE0RYW4SWFRNEWF2ErJggwuoiZMUEEVYXISsmiLC6CC0iRIS1RciKCSKsLkJWTBBhdRGyYoIIq4uQFRNEWF2ErJggwtoidKyYIMLqIiQnRIQfF6E2TxFa9y5CumNE+HERZt7A5OiOEWF1EdIdI8LqIqQ7RoS1RejpjhFhdRHyPCEirC5CnidEhNVFSE6ICKuL0CJCRFhbhDxPiAiri5AVE1kitHoVoQ0qI8IHdSv7NobnZ/utgSS3IKJSeMEvbAl2Whbiwsti8OPQWVUsgaCq8qpiTQNVXVGVWUoMNr2rikUKVHVJVXoBxJs3VQVWHVDVFVXFtPYB4V1VLCOgqvKqYl0AVV1QVdQLh9G+u/VA0I+qLqlqzc2cf1eVRVWo6oKqwuLW49YMSBSPqv6UqtJGXhXI1oWpakpPVemMqqxRC/nWvGjwoaqZfTLwkdknqx6ZfTLlgdmPZL8js09GOzL7ZKkjs0/mOTL7FvYHZp8McWT2yfpGZp+sb2T2yfp6Zt8+2X/875X9jY8Ofl2Yisq8S4VgEKmck0oiRUQqJ6VC5IhUTkqFfBKpnJQKYSZSOSkVi1SQyjmpEJMilZNSIVNFKielQgCLVE5KhbQWqSzDti/DDu9SIa1FKqek4ibSWqSyDNvrddivA1mkQlqLVE5KhbQWqSzDTmr56DS5d6mQ1iKVk1KxSAWpvEvlvVl2E2ktUjkpFdJapHJSKqS1gqXiM1JRk1130Jh+f1x2o8jna2WdVvZdKqS1SOW7SG39KhW/0SyT1iKVRSpplYox72mtIq1FKielQlqLVL6LNGE52NnX/b4WqZDWIpXvIm1Y4HOPzvhdKqS1SGWRivdPqWxMQBapIJW5SB+WXMUFlQlhgjcLicHH9xBGEe2iq0/oihwYXX1CV4TG6OoTuiJhRlef0BVxNLr6gK402TW6uqSrtPwuJgSl3nVF0I2uPqErUnF0dUVXYR11CCa964oIHV19QlcWXaGrnK5mqRChI5WTUiEVRyonpULQjVROSoXsGqmclApxNFI5JxVDwoxUTkqF0BipnJQKOTBSOSkVol2k8l1kVKtUotPHB+eWzo1FV+jqA7oiB0ZXn9AVoTG6+oSuSJjR1Sd0RRyNrj6hK7JrdHVJV8ePJlqCbnT1CV2RiqOrK7rKPJpoidDR1Sd0Rd6Orr6LzGyHZS1SQSofsExE6OjqE7oiQkdXn9AVETq6+oSuiNDR1Sd0RYSOrj4QHTgidHT1CV0RoaOrT+iKCB1dfReZefWMIxVHKtlb0CwVi1SQyjmpEHQjlZNSIQtCKielQryDVM5JxZPYIJWTUrFIBamckwq2FqmclAqPZCCVk1KhA0IqJ6VCB4RUzkkl0AEhlW9elF55Uf79cffAMjRSWaQy2adU4rtUWFlGKielwsoyUjkpFYtUkMrMywPrhRft/LtUiOCQynJXWYt8SGXD1hLBIZWTUuGHTkjlpFRIa5HKSamQ1laXyhT3pPJFUSQlbZ4i0snmKSIV/ABFcZ230uRyFKl1llNfn7ccPW1NXFYvPba1zzlOp61jzdqPG6t/O3amnpRvWOot1I9KPSncsNSTqg1LPSnZsNSTeg1LPSnWqNQn0rFhqSd1G5Z60rxhqSfNk0W90iv1NkN9SHYddUrPUes4bXK4sGL1E47NAvVziyGtlX49eBaVRVSIqrSoSCARVXFRkW0iquKiIjVFVMVFRR6LqIqLiqQXURUWlZ/IkBFVcVGRTiOq4qIi90ZUxUVFoo6oiovKIipEVVpUJOqIqrioSNQRVXFRkagjquKiIlFHVMVFRaKOqEqLSpGoI6rioiJRR1TFRUWijqiKi4pEHVEVF5VFVIiqtKhI1BFVcVGRqCOq4qIiUUdUxUVFoo6oiouKRB1RlRaVJlFHVMVFRU6FqH4sKm2eorLuXVR0f4jqx6IKahmyDsa8i4ruD1EVFxXdH6IqLiq6P0RVWlSG7g9RFRcVz1MhquKi4nkqRFVcVORUiKq4qCyiQlSlRcXzVIiquKhI1MuLKpn1o5NLGVEZtw5avXzy5tt8w1rgKxbKbY3CrQw6r387diae1HtQ4kmmByWe9HhM4i0J76DEk8IOSjxJ6aDEk2YOSryF+DGJJxXslXi/HOunlDlWTSvKaopPtrVz3zIh50MmJ2RCKvgBmfh1zFPKySQqv3x21C+Ebq8E2Ditb7+ML2sBxulvQkn7OiOUFK8vQh3pXGeEkrp1RihpWmeEkpJ1RqiF0L4IJdXqjFDyp84IJSnqjFCSooYJnSki+2mdIk+a0zxF5DO1KdLqSZHTmZmr2hZWntwHoZwSCnkSQjklFItQEMoZoZB/IZRTQiFXQyinhEJeh1BOCYUcEKGcEgppJEI5I5RAJopQTgmFZBahnBIKySxCOSUUklmEckooFqEglDNCIZlFKKeEQjKLUE4JhWQWoZwSCsksQjklFJJZhHJGKJFkFqGcEgrJLEI5JRSSWYRySigkswjllFAsQkEoZ4RCMotQTgmFZBahnBIKySxCOSUUklmEckYoiRwFoXzhoc1TKNa9C8UiFITyC4/MC/wSXQ9COSUUuh6EckoodD0I5ZRQ6HoQyimh8DwKQjkhlDDxPApCOSUUchSEckooPI+CUE4JhedREMopodD1vAllBgaXvw2MwtU+gDH2+INVXFdEVHxBw/pvFLF8JVDED5VAEbNQAkULigVQZAGwBIqsjpVAkaWjEijSYZRAkXakAIqa3qUEivQuJVCkdymBIr1LCRQtKBZAkd6lBIr0LiVQpHcpgSK9SwkU6V0KoGjoXUqgOGrvYrRZVpiNzn2wNno5+IGGWg/eXo4u++reYEZtjARRNGrXJYgiC0WtUzRqvyiIolGbUUEUjdrpCqJo1DZaEEWj9uhyKLKjBgCCKCJdaJ4i0oVbKZpBJy+oALoF9PtBp6cvD7qI3dCCJSsYlnoyiGGpJ9sYlnoyk1Gpd2Qxw1JPxjMs9WRHw1JPgjUs9RbqR6WeNG9Y6knzhqWeNG9Y6knzhqWeNG9U6j1p3rDUk+YNSz1p3rDUk+YNS72F+lGpJ80blnrSvGGpJ80blnrSvGGpJ80blfpAmjcs9aR5w1JPmjcs9fT13VKvzZN6696px+F3S33mzXUBhz8q9RGHPyz1OPxhqcfhD0s96/XDUm+hflTq6euHpZ71+mGpZ71+WOqHTfOM0cuQTVIZ6p970D3i0ZCjvuz2mXHY1E0MRWnYdEwORcOmWHIoGjZtkkPRsKmQHIosFLVO0bApixyKhk1D5FA0bGohhyLSheYpIl24laJfoMeJvKAC6CQAFUCnpy8PuohnxONEVjAs9RbqR6WebGNY6slMhqWeLGZY6sl4hqWe7GhU6hUJ1rDUk6MNSz1p3rDUk+YNS72F+lGpJ80blnrSvGGpJ80blnrSvGGpJ80blXpNmjcs9aR5w1JPmjcs9aR5w1JvoX5U6knzhqWeNG9Y6knzhqWeNG9Y6knzRqXe0Nd3S/3xyzmiweF3S/3xTo7R4PCHpR6HPyz1OPxhqcfhj0q9Zb1+WOpZrx+Wevr6YalnvX5Y6i3Uj0r9sGmenZYPNtbZ1w+egRm2680BM2xPmAHGjdoxWRWWu6hVLzev7Q/eP3hGcdTmoyyKo/r4H6Hoo1uWunwMz+nff4M4qiMuCqIFxD8P4qgu7Wcgpmkx0T7p8AbiqKuXRUEcdR2wKIij9hZFQRy1DykJoqdnKQAiLUsBEOlYCoBIx1IARAuIfx5EOpYCINKxFACRjqUAiHQsBUCkY/nzIAY6lgIg0rEUAJGOpQCIdCwFQLSA+OdBpGMpACIdSwEQ6VgKgEjHUgBEOpY/D2KkYykAIh1LARDpWAqASMdSAEQLiH8eRDqWAiDSsRQAkY6lAIh0LAVApGP58yAmOpYCINKxnALRrg++J/cOIh1LARDpWAqAaAHxz4NIx1IARDqWAiCOYbZ/1ZomdvbodnsHs3KojbKvB8/UjzprQf3EPr3DUs8+vcNSzz69w1LPPr3DUs8+vaNSr9int983cSS9Uj+5d+rZp3dY6tmnd1jqSfOGpd5C/ajUk+YNSz1p3rDUk+YNSz1p3rDUk+aNSr0m0hmW+mFtnjYL4kbnPlgbvVJvrRJCfSbD18PaPKgf1uZB/bA2b3jqzbCLtlA/rMOH+mEXbaF+2EXb/qnP9PXGQv2o1A+7aAv1pHnDUk+aNyz1pHnDUk+aNyr1ljRvWOpJ84alnjRvWOot1I9K/ag2T6dpWoas1HT8wS6llZ7oTA6N5NcxTymtR5skOPF3o5pChPJDoYxqIRHKD4UyquFEKD8UyqiLzQjlh0KxCAWhnBHKqAvZCOWHQhl12Ruh/CxHcaMukiOUHwpl1CV1hPJDoZDMIpQzQvEkswjllFBIZhHKKaGQzCKUU0IhmUUop4RiEQpCOSMUklmEckooBG4I5YxQAma2vFBiXMb868VcGaE8vnw5Wn193nL05LdKVOtLEe3Lgkzyt4oqsy4UML6IqrioLKJCVKVFhaFGVMVFxWMRiKq4qOjoEFVxUfG4BaIqLioezUBUpXOqyGMciKq4qHjkA1EVFxWJOqIqLioSdURVXFQWUSGq0qIiUUdUxUVFoo6oiouKRB1RFRcViTqiKi2qRPiJqIqLCqP+AVFps6Lhppyo7LplprLhCcdDYVuf/QBk+WwTnrxov3W0kB1EEsYeEVYXIY0AIqwuQhoHRFhdhDy6gwjritBOE90uIqwuQh4NQoTVRcijRIiwbk74ECGPHiHC6iK0iBAR1hYhKyaIsLoIWTFBhNVFyIoJIqwuQlZMEGF1EbJigghri1CxYoIIq4uQFRNEWF2EhNWIsLoIaUxkiVCF57Cjz4jQTEatR7vwHMnmTwGErDQr2hgkK0uymqYHyQqTLC0SkhUmWR5BQ7LCJEsGgGSFSdYiWSQrS7I8DIdkZeWymkfnkKwwyfKgHZIVJllWv5CsMMmy+oVkZUnWsPqFZIVJltUvJCtMsqx+IVlhkmX1C8kKk6xFskhWlmRZSkCywiRLyIVkF8kq/5TslDIi/EXHk5nnSMxD7F/SsoRRSOuatKKyC9pRpQ1pERohrYvSWqu00egNaRHuIK0PSYsQBml9SFoWaSGtz0iLR3qR1oekRV6GtD4kLR6RRVofkhaPsiKti9Kawiqtl+T+KS3SeKT1GWk50nik9SFpkcYjrQ9JizQeaX1IWqTxSOtD0rJIC2l9Rlqk8UjrQ9IijUdaH5IWaTzS+pC0SOOR1oekRRqPtD4jLW+RVl5awejl4BBsTlrK6+WpcRVexWLVtlhW7LQOmaP1k36tTcjQL2SzRk8viQiri5CuExFWFyH9KSKsLkI6WURYXYT0vIiwtggDz6ohwuoi5Kk2RPhxEWa2Zwk8/4YIq4uQJ+UQYXURWkSICGuLkBUTRFhdhKyYIMLqImTFBBFWFyErJoiwughZMUGEtUUYWTFBhNVFSFiNCKuLkMaktginaX2wfoq5o7VZH/F/8KKEiDCzdhxpTBBhdRHSmCDC2iJMNCaIsLoIeZQLEVYXId0xIqwuQh7lQoTVRWgRISKsnBMmHuVChNVFyKNciLC6CFkxQYTVRciKCSKsLkJWTBBhZRGqiRUTRFhdhKyYIMLqImTFBBFWFyErJoiwuggJqxFhbREqGpPyIgzTusF58CkjqxiXvdMfXWJWgx1uyqUUfQkarK1B2hI0WFuDdCVosLYGLRpEg5U1SGOMBmtrkIe40GBtDfIMFxqsnQ/yCBcarK1BnuBCg5U1qFknQYO1Ncg6CRqsrUHWSdBgbQ2yToIGa2vQokE0WFmDrJOgwdoaZJ0EDdbWIBk1GqysQUNPUluD68ExmJwEO9yBSxmLBJFgXQnSkSDByhKkIUGClSXIc1tIsLIEaYmRYGUJ8tQWEqwrQctDW0iwbi5oeWYLCVaWII9sIcHKEmR1BAlWlqBFgkiwrgRZHUGClSXI6ggSrCxBVkeQYGUJsjqCBCtLkNURJFhXgo5oGglWluCw7Yizywdrl+LxB6uYlsfr9WQ6WZt1w7YBUD+s/Yb6YW3v8NT7YR/GgfphOw2oH/bhE6gf9qGP/qnP9PXeQv2o1A/7kAPUk+YNSz1p3rDUk+YNSz1p3qjUB9K8YaknzRuWetK8Yam3UD8q9WWaO6vWp66sy1Dvgl4YciGp44OVDXYZiFMvD1KlaVNVy8HeqRfu03exsatiwyIZH91GsamvYtVarH8vNk4jFatGKlaPVKwZqVg7UrFupGJ9V8V6vTrVuFFsXw4qU2xfDipTbF8O6rjY1JeDyhTbl4PKFNuXg8oU25eDyhRrRyq2LweVKXYkB5VGclBpIAelpzLz7DSFpdjJ2Mz4TfLrC2vsNL2Uu50Ax7gmwPHlR52PEHYuQcsvwcgvwcovwckvwcsvITVfgk9LuPL407yXoNq/I8W4Lqull0WnZwnN35HMpJ+frTeEpJq/I+VLaP6OlC+h+TuSmYJePzv+fjn/7Oi54DBawbGvgh9rtesadQzPj/bf5TY/PxUtV09jldt8P/TDctO6y41POryV27xTKVuuAFdTslw7VrkC3FLJcjtzVrlyO/NVuXJ7c1WZcntzVcflmt5cVabcsVyV6c5VPZ/aTe693O5c1XG5dqxyu3NVx+V256qOy+3OVR2XK9pVfZVg21+xDWbhQIeXnxk9S2h/fSRbQvsrttkSmp/H8iW0v2KbLaH9FdtsCc3PIfkSmp8X8iW0v27+Wwn2vQTXfFecL0HY7LxVgrDZeasEAbOzfpZgsmuwOq0/3H7d7PHb1ToBM3nJcgXM+iXLFeAQflSu8WktN762aO/H/noa9/vYX09WvEEjwHnUgkaAo6kFjQCnVAkaL8CB1YJGgLOrBY0Ax1gLGtFOdC7Btl+CD2sJIW6UIMAxxvWZ8pA2nqP1AlzgCwubJQhwa7kSBLiqTAmh/XksuvVle9FtlSDg9xW5EtqfF7IltD8vZEtof17IltD+vJAtof15IVp9WEJsv2/K/eIrCpgXciXI/91dFDAv5EoQcFPNlVDD5vl1z1BlgtbHJSinzXq401b/sfGMSUAJXj1LeHlf83cJaZJfgpJfgpZfgpFfgpVfgpNfgpdfQpBfgoTZOVOC+Nn58d3ySxA/O5upxrxg1boBlbHBHJdwvOO7qbLpzs8KONzF3VTZcueHBRztBWymIL2AKL2AJLwANUkvQEkvQEsvwDRfwOFOiqbKdlNFC2h/Js4U0P5MnCmg/Zk4U0D7M3GmgPZn4uMCdPszcaaA9mfiTAHtz8SZAqTPxFW2PSpagPSZuMbmNTqYsH54fHkScztYUTEu+3MrlV5WDLce8kwqLANPKv7xIU9TY/OaiuXW2Lzmo+U+XwSZtH4vV41Vrh6rXDNWuba3co1ayzVv8XiNzWtqluvHKjeMVW5vripTbm+u6rhc252rOi63O1c16ee8G9/K7c5VHZfbnas6LteOVW53ruq43O5c1XG53bmq43K7c1XH5Xbnqg7Ldd25quNyx3JVbixX5cZyVTW2tapZbo151+hnuSZmnkbNPMpZY8uhHxZw/ChnjY2BflrA4UNUNbbvKVuAkl6All6AkV6AlV6Ak16Ab76A48cXfPszcaaA9mfiTAHtz8THBYT2Z+JMAe3PxJkC2p+JMwW0PxNnCmh/Js4U0P5MnClA+kwcpM/ENTYGesQM62YoWplMAXqK695G2j3t3K/C3z87xKWDfvwZXg+ey1V9lRvV+uvb+PJ287VcPVa5Zqxy7VjlurHK9WOVG8YqN3Y27667TKs4xfdy01Dlpt5cVabczlxVrtzOXFWu3M5cVa5cO1a5nbmqXLmduapcuZ25qly5Y7mqNJSrstNQrspOQ7kqO/WWVT13fI4+vZfbW1Zl11A6hum9XDtWub1lVZlye8uqMuX2llVlyu3MVeXK7cxVZcpVnbmqaNJa7su7l9dye1sBzJTbm6vKlNubq8qUa8cqtzdXlSm3N1eVKbc3V5UptzdXlSm3N1d1XK4ey1XpsVxVjR0cP1nu8wcTKqgpc7Bd38esbLDHB3v7fPrw+TSe+fX327EprvngpFLmYK/dgp3XMffRv34G+SQ0vpT46/iZ0s68xQCUWvek1JkNSjvzT1BqdWceEUqt7swHQ6nVnXl9KLWms34GSq3prGeDUms6S/sHo9TrDUo7W9EYgVL7pDS43Kenad2sIr3s56S2oI56/eyoX9TyOHgWi0UsiOWsWEi8EMtpsZClIZbTYiGlQyynxUL+h1hOi4VkEbGcFYsls0Qsp8VCGipMLEk/d9hI2r9HZ1XeegKlf+b6T8+ndNK08ZSOpbOQdpWqZ8CdjHqn1DFL93aVOuZSyXOp2aKUlcXuKGVlsTtKLZT2RimrdNIoNc8QI738eORJKWtp3VFKX9odpaxLdUcpq0e9UepJj7qjlPSoO0pJj6RRmovtPelRd5RaKO2NUtKj7iglPeqOUtKj7iglPeqOUtKj3igNpEfdUUp61B2lpEfdUUp61B2lFkp7o5S+tDalaj36we6UozRos3540HZjh6BAX9odpfSl0ih9vhos6JDeKY30pcIoNU9mgtF6g1L60u4opS/tjlL60u4otVDaG6U81dAdpTzV0B2lpEfSKLUvlDq3QSnpUXeUkh71RmkiPeqOUtIjaZSaV0o3didLpEfdUUp61B2lFkp7o5T0qDtKSY+6o5T0qDtKSY+kURqnJ6Vx40GVRHrUGaVuIj3qjlLSo+4oJT2SRml4oTRNG5SSHnVHqYXS3iglPeqOUtKj7iglPeqOUtKj7iglPRJGqVXroIPV7z9GdIr0qDtKSY+6o5T0qDtKSY+kUTq9Umo3KLVQ2hulpEfdUUp61B2lpEfdUUp61B2lpEe9UapJj4RRquNzKytrXO54a9R6vN361bjTpE29S8C4pwScyh4f3Tp4G0PckAxpVu+Scc8ijd9IvzTp10h3jU0JWCQwugRI14aXAGnc8BIgvetdAsE/JZB0gQ6CdLB3yaTnXeMRQ21IgDRxoLvGpgQM6ePwEiB9HF4CpInDS4A0sXMJWBWeEjDmz3cQxiKZziVjXu4a1m1IgPRxpLvGpgRIH4eXAOnj8BIgTRxeAqSJ0iTgXt7JGDd+rGxJB7ujlLSvO0pJ77qjlDSuO0otlPZGKelXd5SSZnVHKelUd5SSNnVHKelRb5Q60qPuKCU96o5SC6WiKPXJrysxPoWNFyU4+lJplKbntrHTpDcopS/tjlL60u4opS/tjlL60t4o9fSl3VFKX9odpTzV0B2lPNXQHaUWSnujlPSoO0pJj7qjlPSoN0oDfWllSp0y6ftop6LNHB2sXz778efGOkygK+2MUHrSzgjF68oi1MVlzMGlrTmUFRhZhIa0YBeiURuEsv7SF6ERlyuL0OjUSujW3rMRl9sZobjczghl3aUzQi2E9kUofWhnhLLi0hmhrLd0RihJUWeEkhT1RWgiKeqMUJKizgglKeqMUPpQWYR6tbzjKXgdNgilD+2MUPrQzgilD+2MUPrQrgj1E31oZ4TSh3ZGKH1oZ4TyxIJcQjee+vOThdC+CCUp6oxQkqLOCCUpEkaoX5+c9xvvW/UKlyuM0LQgHYJyG4Ticjsj1EJoX4TicjsjFJfbGaG43M4IZT20L0I1qy2yCA3rKyMef9oNQulDhRH68pN8ZTJHKxvdOhQbt4IITd8qSwBR+VUAW1GhthAq9oreJJS+tTNC6Vs7I5S+tTNC6Vs7I5TnePsi1Izct2rzLNKr14NnbEZu6YxaPlkZY9+xsWCzi83IjUYOm5E9ew6bke1vDpuRnWQOm5FNWQYbO/LvlHR4YjOld2xGXoTKYTO0L85gM7IvzmFjwWYXm5F9cQ6bkX1xDpuRfXEOm5F9cQ6bkX1xBhuHL97HBl+8jw2+eB+bCv5GOb0c/fj7ZalhGxttzROb51NPKm3Va3RaFiaMUc+R+O9y/Vjlhs7KNT6t5cbwUu77sVat0Fitwhs0EWj2oElAswONn4BmDxoFNHvQaKDZg8YAzR40tnlojF22LtAmTBloXFhwdOlpRFX8rrZ9I1qy2vZ9aMlq27ehJatt31mWrLZ9s2jj0i9rm2KmWp+m5WifXm7Kauuj46O074Oj9voNnNC+XawITvuGsSI47VvGiuC0bxorgmMBZx+c9l1mRXDaN6UVwWnf57h1yeHxp/sNnK8SYvtzirPTWoKbNkpo//p166tZHis5caOE9q+ybAnt93PZEtpv0rIlCLgjZUpI7fdH2RLa72KyJYieFy7MIqn9/qFwwbavgh8+YDFrj8no+Su47+Q8CXAJJcsV4ChKlivAffyo3DS5tU3Rb8tASYBTKVmuAFdTrtwwCXBAJcsV4JZKltuZs8qV25mvypVrxyq3N1eVKbc3V5UpdyhXFabuXNUaXz/an/dyu3NVh+Wq7lzVcbnduarjcrtzVcfldueqjsu10lepQo297JXW64crO03HJfzaDGw52qnXh1qnLcaehLlnHKNi+i43dlZuWJ1DdBvlpt7KXVfJo38vV09jlavGKlePVa4Zq1w7VrlurHJ9Z+X65/6jcaPc3lxVptzeXFWm3N5c1XG5pjdXlSm3N1eVKbc3V5UptzdXlSnXjlVub64qU+5YrsqM5arMWK7Kbd6qbFjGY1/7iuS+T3JXTvJXTtoUn1NL2+O0+e2kjSw2+vWnrDG+hpPf3xA//g3p09+wvelI0W9QH/8G/fFvMB//Bvvxb3Af/wb/8W/4+DXtP35N+49f09u/0nTrQouz4f12GbahXecLb6eNk9KFb4rbt5z1hZLO242Ttu8i69Z2LpmNk/SVk8yVk+yVk7avyDitJ20B4a+cFK6cFK+clC6ctP1TndxJ6spJ+vgkP23wtP2TDhfSelLcOGlTEX7dnd+btHGSy3zT1kW4/Yh+5spNVy737cfFj0+Ke8+purSaYp82TjPXTrPXTnPXTvPXTgvXTovXTkuXTtt7zil3mrp22o5K4vrshE564zSTP81vnGavneauneavnbatEjO9bLoaN06L105Ll07bWcHPnqaunaavnWaunWavnbZDgF/pNuF9lok7MfbTGCpnN66AnXzUpPV6s5PbOM3mT9u4THfyuuxp/tpp4dJpO++4yZ62jaTVbj3t5Y2Bz9PstdO2kbR+Wk/zGzeFnf3trX/WFjYmYbdTm1ul/EB74zR77TR37bRtldj0zKymrdrCtdPitdPSpdN2Nnd1auXt9201ltPUtdP0tUGaa6fZa6e5a6f5S/fJnX0Cs6fFa6elS6ft7MyVu3OFa3eucO3OtbPPUea0tP0AjVvja/fyQ4pHMD6f4y+cEy6cEy+ck35+zvbKfOYcdeEcfeEcc+Ece+GcCzrY9g9unSvdy9tq13PChXPihXO2dbDexR4t/9s52w4lc466cI6+cI65cI69cI67cI6/cE64cE68cM4FHbgLOnAXdLDtdXRYbYQOxryftT2Jeb++fcTH9+thx+nkzlKXztKXztqeLsO6nqhCcu9n2UtnuUtn+UtnhUtnxUtnpStn7exZmztLXTpLXzrrkjbCJW2ES9oIl7QRLmkjXNLGznaG6flm2qTfz9peFsqetcmXfjS8y50tvozQbD7n8FhDW7dnfNzGc0erdfXtkX49j9Zx6+hfYe/30b/CsudnO/1dgJVegJNegJdeQJBeQJReQBJewPYKrKQClPQCtPQCpM/ESfpMnKTPxKmpmXgeUlNz6zykpmbLeUj3z39aPYfkdEZ5Ia0vpQnp5VGs7aONWx8sflHp5sPaWq25i9Zvwctj/WICmG1gFMBsA6MBZhsYAzDbwFiA2QbGAcw2MB5gtoEJALMNTASYbWBwvtvAKJzvDjA43x1gcL47wOB8d4CxALMNDM53Bxic7w4wON8dYHC+O8DgfLeB0TjfHWBwvjvA4Hx3gMH57gBjAWYbGJzvDjA43x1gcL7bwJhhfYw2T2Csewdm2Fnp8AcjD2CGnZVywAw7K+WAGXZWygEz7KyUA2bYPCYHzLB5TAYYO6yPyQEzbB6TA2bYPCYHzKbzNdO64aOZXjZ22S5VqWiXrR4ff3udOV4//re6cfMCu1Hfg7IlBhWeu3GppHyOr5IPvj9KcPJL8PJLCPJLiPJLSOJL2N7WQVYJSn4JWn4JRn4J8mdn19jsPA+qsfl2HlRjM+g8qBpzooyI3yWg2YHGT0CzB40Cmj1oNNDsQWOAZg8aCzR70Dig2YPGA80eNAFo9qDBDe9CgxvegybghnehwQ3vQoMb3oUGN7wLjQWaPWhww7vQ4IZ3ocEN70KDG96FBje8B03EDe9CgxvehQY3vAsNbngXGgs0e9DghnehGdjXZH69lQaeoTKP96aBZ6gcNAPPUDloBp6hctAMPEPloBk4r8lBM3Bek4NmYF+Tg2bgvOYYGjUNnNfkoBl4hjLTcqw2yr5DM/AMlYNm4BkqB83AM1QOmoFnqAw0auAZKgfNwHlNDpqB8xqd1l+Fm8m9QzNwXpODxgLNHjQDu+EcNAO74Rw0A7vhHDQjr0NloBnYDWeg0QO74Rw0A7vhHDRYvl1oht00L9NB6WE3zcsAM+7mvzlght00LwfMsJvm5YAZdrvoHDAWYLaBGXa76IyPGXe76Bwww24XnQNmWOebA2ZY55sBZtztonPADOt8c8AM63xzwAzrfHPAWIDZBgaDtw3M9nafalqf7lOTj+9nhUtnbXqmx5K6WZNRp97PSlfO2t5mMXuWunSW3j5r3T/0sVz1jsb2DmQPmzAtZ9lp47v8pbPCpbPipbO2+XJ6xdC56e2s7Y2AsmepS2fpS2eZS2fZS2e5S2f5S2eFS2fFS2dd0kbc0UbQ61lJv5+lLp2lL51lLp1lL53lLp3lL50VLp21zbJR61m/3rHxx7PSdOksdeksfeksc+kse+ksd+ksf+mscOmseOmsK9rQ03TprB1t2HUl1vjp/Sx96Sxz6Sx76Sx36Sx/6axw6awrzkFvP8edO2v7EefsWerKWdvv0wlmsb3BmvdzNrFIdpFucu79nPTzc7ZfDpI5R104R1/w/nr7jRPZs+yls9yls/yls8Kls+Kls9KVs3Y6odxZ6tJZl7ThL2nDX9KGv6QNf0kb2/3T8d1iu3tK05I8JP1+Trhw5W93M5nvsRfOcRfO8RfOCRcwuHBnDhfuzPECP/HCnXm7d8mcYy6cs60Dt+g6Bf1+jrtwjr9wTrhwTrxwTvr5OdsdTuacnA62zrmgg3RBB9udTeYcd+Ecf+GcC/eDdOF+kH5+PzDTdOEcdeEcfeEcc+Ece+Ecd+GcH+rgvx//9v/+w7/99R/+8W///O+PM379x//8l3/6j7/+6798/+t//H//d/kv//hvf/3b3/76f/7+//7bv/7TP/+v//y3f/77v/3rP/36b3+Zvv/xP22M4e9smuJjNL/ocPqRWz3Munr8+y/YHgNx+td/+zo4WPV3j3/4X//H19GPmOvvHv+wj3E9xvb/Aw==",
      "brillig_names": ["process_log"]
    },
    {
      "name": "_approve_bridge_and_exit_input_asset_to_L1",
      "is_unconstrained": true,
      "custom_attributes": ["public", "internal"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "9283123155612446889": {
            "error_kind": "string",
            "string": "Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "token_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JwACBAEoAAABBIBQJwAABAMnAgQEAycCBQQAHxgABQAEgE0dAIBPgE8GLgiATQABLgiATgACLgiATwADJQAAAFglAAAAvSgCAAEEgFAnAgIEADsNAAEAAigAgEMAAAEsAIBEADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAKACARQQAAygAgEYBAAAoAIBHBAAAKACASAAAACgAgEkBAAEoAIBKBAABKACASwQABCgAgEwEAB8mJQAAD5ktCAEFAAABAgEuCoBGAAUtCAEFAAABAgEuCoBIAAUtCAEFAAABAgEnAgYAAi0OBgUeAgAFAB4CAAYAMzgABQAGAAckAgAHAAABESUAAA/CHgIABQEeAgAGAAo4BQYHJAIABwAAAS0lAAAP1CcCBQIxJwIGAmQnAgcCKCcCCAJsJwIJAm4nAgoCYicCCwIyJwIMAiknAg0CRicCDgJpJwIPAl8nAhACdScCEQI4JwISAiwnAhMCZScCFAJjJwIVAnAnAhYCci0IARcnAhgEIAAQARgBJwMXBAEAKBcCGC0MGBktDgoZACgZAhktDhAZACgZAhktDhYZACgZAhktDgkZACgZAhktDg8ZACgZAhktDhUZACgZAhktDhAZACgZAhktDgoZACgZAhktDggZACgZAhktDg4ZACgZAhktDhQZACgZAhktDgcZACgZAhktDgcZACgZAhktDg0ZACgZAhktDg4ZACgZAhktDhMZACgZAhktDggZACgZAhktDgYZACgZAhktDgwZACgZAhktDhIZACgZAhktDhAZACgZAhktDgUZACgZAhktDgsZACgZAhktDhEZACgZAhktDhIZACgZAhktDg0ZACgZAhktDg4ZACgZAhktDhMZACgZAhktDggZACgZAhktDgYZACgZAhktDgwZLQ0XBQAoBQIFLQ4FFy0IAQUnAgYEAgAQAQYBJwMFBAEAKAUCBi0MBgcuCoBIAActCAEGAAABAgEtDgUGLQgBBQAAAQIBLgqARwAFJwIHAgAtCAEIJwIJBCAAEAEJAScDCAQBACgIAgknAgoEHwA4CgkKLQwJCww4CwoMFgwMDCQCAAwAAANKLQ4HCwAoCwILIwAAAystCAEJAAABAgEtDggJLQgBCCcCCgQgABABCgEnAwgEAQAoCAIKJwILBB8AOAsKCy0MCgwMOAwLDRYM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",
      "debug_symbols": "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",
      "brillig_names": ["_approve_bridge_and_exit_input_asset_to_L1"]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["sync_notes"]
    },
    {
      "name": "lend_private",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "16275222249430394394": {
            "error_kind": "string",
            "string": "input_asset address is not the same as seen in the bridge contract"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "input_asset",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_asset_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_transfer_to_public_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret_hash_for_L1_to_l2_message",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_L1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Rb2Qeq3Ur7TXJ/Xfon4lN4PUf4v6lfwaUv8t6leyr0j9t6inm6eV+kA3Ty31dPPUUk83Ty31dPPUUi+kXiv1dPPUUk83Ty31dPPUUk83Ty31dPO0Uh/p5qmlnm6eWurp5qmlnm6eWuqF1Gulnm6eWurp5qmlnm6eWurp5qmlnm6eVuoT3Ty11NPNU0s93Ty11NPNU0u9kHqt1NPNU0s93Ty11NPNU0s93Ty11NPN00p9ppunlnq6eWqpp5unlnq6eWqpF1KvlXq6eWqpp5unlnq6eWqpp5unlnq6eVqpL3Tz1FJPN08t9XTz1FJPN08t9ULqtVJPN08t9XTz1FJPN08t9XTz1FJPN08p9cHQzVNLPd08tdTTzVNLPd08tdQLqddKPd08tdTTzVNLPd08tdTTzVNLPd08rdRbunlqqaebp5Z6unlqqaebp5Z6IfVaqaebp5Z6unlqqaebp5Z6unlqqaebp5V6RzdPLfV089RSTzdPLfV089RSL6ReK/V089RSTzdPLfV089RSTzdPLfV087RS7+nmqaWebp5a6unmqaWebp5a6oXUa6Webp5a6unmqaWebp5a6unmqaWebp5W6oVunlrq6eappZ5unlrq6eappV5IvVbq6eappZ5unlrq6eappZ5unlrq6eZppT7QzVNLPd08tdTTzVNLPd08tdQLqddKPd08tdTTzVNLPd08tdTTzVNLPd08rdRHunlqqaebp5Z6unlqqaebp5Z6IfVaqaebp5Z6unlqqaebp5Z6unlqqaebp5X6RDdPLfV089RSTzdPLfV089RSL6ReK/V089RSTzdPLfV089RSTzdPLfV087RSn+nmqaWebp5a6unmqaWebp5a6oXUa6Webp5a6unmqaWebp5a6unmqaWebp5W6gvdPLXU081TSz3dPLXU081TS72Qeq3U081TSz3dPLXU081TSz3dPLXU081TSn00dPPUUk83Ty31dPPUUk83Ty31Quq1Uk83Ty31dPPUUk83Ty31dPPUUk83Tyv1lm6eWurp5qmlnm6eWurp5qmlXki9Vurp5qmlnm6eWurp5qmlnm6eWurp5mml3tHNU0s93Ty11NPNU0s93Ty11Aup10o93Ty11NPNU0s93Ty11NPNU0s93Tyt1Hu6eWqpp5unlnq6eWqpp5unlnoh9Vqpp5unlnq6eWqpp5unlnpw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",
      "brillig_names": [
        "discover_new_notes",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "build_msg_block",
        "attach_len_to_msg_block",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    },
    {
      "name": "lend_public",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_asset_bridge",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "input_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_transfer_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "secret_hash_for_L1_to_l2_message",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_L1",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_lend_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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LgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQAhAuCoBXABAAKBACEC4KgFcAEAAoEAIQLgqAVwAQACgQ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CQYtDgoBASgABYBbAAItDAIFIwAAKa8uAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAqliMAACsGJACADQAAKqMjAAAqvC4AgAOABQEAgAUAAoAOLgKAC4AOIwAAKwEoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAAKwEjAAArWigAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAArWigAgA0EAAMBAIAFgA2ADAsAgAOABYANJACADQAAK74BAIAKgAiADy4AgAqAEC4AgAyAEQsAgBCAD4ASJACAEgAAK74uAYAQgA4uAoAOgBEBAIAQAAKAEAEAgBEAAoARIwAAK40BAIAMgAiABiYuAYADgAcBAIADAAKACy4BgAuACAEAgAsAAoALLgGAC4AJAQCACwACgAoBAIAIgASACw8AgAuACYAMCwCABwACgA0kAIAMAAAsFiMAACyGJACADQAALCMjAAAsPC4AgAOABQEAgAUAAoAOLgKAC4AOIwAALIEoAIAPBAADAQCACYAPgA4uAAABgAUBAAABgA4AASgBgAUEAAEBAIAFAAKADi4CgAuADgEAgA4AAoAOLgKACYAOIwAALIEjAAAs2igAgA8EAAIFAIALgA+ADigAgBAEAAMBAIAOgBCADy4AAAGABQEAAAGADwABKAGABQQAAQEAgAUAAoAPLgKAC4APAQCADwACgA8uAoAOgA8jAAAs2igAgA0EAAMBAIAFgA2ADAEAgAyABIANAwCACAACgA4BAIANgA6ADwEAgAqADoAQDQCAEIAKgA4kAIAOAAAtOi4BgBCAES4CgBGADwMAgBAAAoAQAwCADwACgA8jAAAtCS4AgAyABiYqAQABBfWSDTV0reEYPAEBAiYlAAAlpScCAwEALQgBAicCBAQhABABBAEnAwIEAQAoAgIEJwIFBCBDA7AAAYBVAAUAAwAELQ0CAQAoAQIBLQ4BAi0MAgEmJQAAJaUtCAEFJwIGBBEAEAEGAScDBQQBACgFAgYnAgcEEAA4BwYHLQwGCAw4CAcJFgwJCSQCAAkAAC3lLgqAWAAIACgIAggjAAAtxC0IAQYAAAECAS0OBQYMOAIDBSQCAAUAAC5kIwAALgQBKAADgE8ABw44AwcIJAIACAAALh4lAAAwpgw4AgcIJAIACAAALjsjAAAuMC4IgE8ABSMAAC5bAjgCAwcOOAMCCCQCAAgAAC5SJQAAMHAtDAcFIwAALlstDAUEIwAALm8uCIBYAAQjAAAubwcoAASAUAACLQgBBQAAAQIBLQ4CBScCCAQEBjgECAkEOAkICgI4BAoHCygAB4BYAAgkAgAIAAAu0CMAAC6tASgAAoBbAAcOOAIHCCQCAAgAAC7HJQAAMKYtDgcFIwAALtAtDQUHLgiAWAACIwAALt8MOAIHBSQCAAUAAC76IwAALvEtDQYBLQwEAiYtCAEIAAABAgEuCoBYAAguCIBYAAUjAAAvFA0oAAWAUAAJJAIACQAAL4MjAAAvKS0NBgUtDQgJJwIKBBAMOAIKCyQCAAsAAC9IJQAAJ6AuBAAFgAMoAIAEBAARJQAAKN0uCIAFAAgAKAgCCgA4CgILLQ4JCwEoAAKAWwAFLQ4IBi0MBQIjAAAu3wUoAAKAUAAKJwIMBAALKAAMgFAACyQCAAsAAC+6BygACoBQAA4KOA4CDSQCAA0AAC+6JQAAMIIAOAoFCw44CgsMJAIADAAAL9ElAAAwpgw4CwQKJAIACgAAL+4jAAAv4y4IgFcACSMAADAzADgDCwoOOAMKDCQCAAwAADAFJQAAMKYnAgwEpAw4CgwNJAIADQAAMBwlAAAnoAAoAQIMADgMCg0tDQ0LLQwLCSMAADAzLQ0IChkoAAqAXAALHAwJCgQAOAsKCQ44CwkMJAIADAAAMFslAAAwpi0OCQgBKAAFgFsACS0MCQUjAAAvFCoBAAEFKIaSsEfc/UM8AQECJioBAAEFZGGIqMbPlMs8AQECJioBAAEFyW+TOxOd6RY8AQECJioBAAEFRafKcRlB5BU8AQECJioBAAEFWgLkG7UeqZ88AQECJiUAACWlLgiAWAAFIwAAMNoNKAAFgFQABiQCAAYAADFFIwAAMO8tDQEFLQ0CBi0NAwctDQQILQgBCScCCgQFABABCgEnAwkEAQAoBgIKJwILBAQAKAkCDD8PAAoADC0NCQYAKAYCBi0OBgktDgUBLQ4JAi0OBwMtDggEJi0NAwYMOAUGBwEoAAWAWwAGJAIABwAAMWMjAAAyFC0NAQctDQIILQ0DCS0NBAonAgwEBAw4BQwNJAIADQAAMYolAAAnoAAoCAIMADgMBQ0tDQ0LJwINBAMMOAUNDiQCAA4AADGvJQAAJ6AAKAcCDQA4DQUOLQ0ODAA4CwwNJwIMBAQMOAUMDiQCAA4AADHZJQAAJ6AuBAAIgAMoAIAEBAAFJQAAKN0uCIAFAAsAKAsCDAA4DAUOLQ4NDi0OBwEtDgsCLQ4JAy0OCgQjAAAyFC0MBgUjAAAw2ioBAAEFxWvEWg4QAAI8AQECJi4AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": ["lend_public"]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": ["public", "initializer"],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "portal_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["constructor"]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9283123155612446889": {
            "error_kind": "string",
            "string": "Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"
          },
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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ACgVAhUtDhIVACgVAhUtDgMVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUAKBUCFS4KgFcAFQAoFQIVLgqAVwAVACgVAhUuCoBXABUtDhMMJwIQBGQnAhEEICcCEgREJwIT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IwAATX0COAIDBw44AwIIJAIACAAATXQlAABPki0MBwUjAABNfS0MBQQjAABNkS4IgFgABCMAAE2RBygABIBQAAItCAEFAAABAgEtDgIFJwIIBAQGOAQICQQ4CQgKAjgECgcLKAAHgFgACCQCAAgAAE3yIwAATc8BKAACgFsABw44AgcIJAIACAAATeklAABPyC0OBwUjAABN8i0NBQcuCIBYAAIjAABOAQw4AgcFJAIABQAAThwjAABOEy0NBgEtDAQCJi0IAQgAAAECAS4KgFgACC4IgFgABSMAAE42DSgABYBQAAkkAgAJAABOpSMAAE5LLQ0GBS0NCAknAgoEEAw4AgoLJAIACwAATmolAABIey4EAAWAAygAgAQEABElAABP2i4IgAUACAAoCAIKADgKAgstDgkLASgAAoBbAAUtDggGLQwFAiMAAE4BBSgAAoBQAAonAgwEAAsoAAyAUAALJAIACwAATtwHKAAKgFAADgo4DgINJAIADQAATtwlAABPpAA4CgULDjgKCwwkAgAMAABO8yUAAE/IDDgLBAokAgAKAABPECMAAE8FLgiAVwAJIwAAT1UAOAMLCg44AwoMJAIADAAATyclAABPyCcCDASkDDgKDA0kAgANAABPPiUAAEh7ACgBAgwAOAwKDS0NDQstDAsJIwAAT1UtDQgKGSgACoBeAAscDAkKBAA4CwoJDjgLCQwkAgAMAABPfSUAAE/ILQ4JCAEoAAWAWwAJLQwJBSMAAE42KgEAAQUohpKwR9z9QzwBAQImKgEAAQVkYYioxs+UyzwBAQImKgEAAQXJb5M7E53pFjwBAQImKgEAAQVFp8pxGUHkFTwBAQImLgGAA4AGCwCABgACgAckAIAHAABP9SMAAFAALgCAA4AFIwAAUGcuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAABQUy4BgAqACC4CgAiACwEAgAoAAoAKAQCACwACgAsjAABQIigBgAUEAAEDAIAGAAKABiMAAFBnJiUAADv6JwIGBActCAAHLQwBCC0MAgkAEAAGACUAAFEeLQQAAC0MCAULKAADgF0AASQCAAEAAFDxIwAAUKULKAADgGAAAQEoAAWAWwAGLQ0GAiQCAAEAAFDoIwAAUMYLKAADgGEAASQCAAEAAFDfJwIFBAA8CQEFLQwCBCMAAFEZLQwCBCMAAFEZJwICBAYtCAAGLQwFBwAQAAIAJQAAPCMtBAAALQwHAS0MAQQjAABRGS0MBAEmJQAAO/otDQEDLQ0CBCcCBgQDDDgEBgckAgAHAABRQiUAAEh7ACgDAgYAOAYEBy0NBwUtCAEGJwIHBAIAEAEHAScDBgQBACgGAgctDAcILQ4FCAEoAASAWwAFDjgEBQckAgAHAABRiiUAAE/ILQ4DAS0OBQItDAYBJioBAAEFgNRHU3B7sKk8AQECJiUAADv6LQgBBAAAAQIBLgqAWQAELQgBBQAAAQIBLgqAQwAFLgiAWAADIwAAUdcNKAADgGMABiQCAAYAAFHxIwAAUewtDQQBJi0IAQYAAAECAS0OAwYkAgACAABSCyMAAFI5AzCAYwADAAcDKAAHgFsACA8wgFsABwAJJAIACQAAUjAlAABPki0OCAYjAABSOS0NBActDQYIJwIJBB8MOAgJCiQCAAoAAFJYJQAASHsAKAECCQA4CQgKLQ0KBhwMBggALQ0FBgQ4CAYJADgHCQgtDggEBSgABoBnAActDgcFASgAA4BbAAYtDAYDIwAAUdcBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAUt8uAYAIgAYuAoAGgAkBAIAIAAKACAEAgAkAAoAJIwAAUq4mKgEAAQVaAuQbtR6pnzwBAQImJQAAO/ouCIBYAAUjAABTAg0oAAWAVAAGJAIABgAAU20jAABTFy0NAQUtDQIGLQ0DBy0NBAgtCAEJJwIKBAUAEAEKAScDCQQBACgGAgonAgsEBAAoCQIMPw8ACgAMLQ0JBgAoBgIGLQ4GCS0OBQEtDgkCLQ4HAy0OCAQmLQ0DBgw4BQYHASgABYBbAAYkAgAHAABTiyMAAFQ8LQ0BBy0NAggtDQMJLQ0ECicCDAQEDDgFDA0kAgANAABTsiUAAEh7ACgIAgwAOAwFDS0NDQsnAg0EAww4BQ0OJAIADgAAU9clAABIewAoBwINADgNBQ4tDQ4MADgLDA0nAgwEBAw4BQwOJAIADgAAVAElAABIey4EAAiAAygAgAQEAAUlAABP2i4IgAUACwAoCwIMADgMBQ4tDg0OLQ4HAS0OCwItDgkDLQ4KBCMAAFQ8LQwGBSMAAFMCKgEAAQW+Hj//PqT2+jwBAQImKgEAAQXFa8RaDhAAAjwBAQImLgAYyhjK",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Lending"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "portal_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_approve_bridge_and_exit_input_asset_to_L1_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_approve_bridge_and_exit_input_asset_to_L1_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce_for_transfer_approval",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "secret_hash_for_L1_to_l2_message",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_L1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "nonce_for_lend_approval",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::lend_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::lend_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "input_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce_for_transfer_to_public_approval",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret_hash_for_L1_to_l2_message",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_L1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::lend_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::lend_private_abi"
        }
      ]
    }
  },
  "file_map": {
    "107": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "112": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "116": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/dispatch/mod.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "119": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "123": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform note discovery, since they may need to access notes. This is slightly inefficient\n    // and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $note_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform note discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let note_discovery_call = if NOTES.len() > 0 {\n        create_note_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $note_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_notes`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_note_discovery_call() -> Quoted {\n    quote {\n        /// Safety: note discovery returns nothing and is performed solely for its side-effects. It is therefore always\n        /// safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_notes(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "124": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/mod.nr",
      "source": "pub mod dispatch;\npub mod functions;\npub mod utils;\npub mod notes;\npub mod storage;\npub mod events;\n\nuse functions::{\n    stub_registry,\n    utils::{create_note_discovery_call, find_and_transform_top_level_unconstrained_fns},\n};\nuse notes::{generate_note_export, NOTES};\nuse storage::STORAGE_LAYOUT_NAME;\n\nuse dispatch::generate_public_dispatch;\nuse utils::{get_trait_impl_method, module_has_storage};\n\nuse crate::discovery::MAX_NOTE_PACKED_LEN;\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The note discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_notes`, `do_process_log`\n            /// and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform note discovery of either private notes or partial notes.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n                // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n                // unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let note_discovery_call = create_note_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $note_discovery_call\n        }\n    }\n}\n"
    },
    "125": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/notes/mod.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "127": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "138": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "141": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "144": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "145": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "146": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "147": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "148": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "149": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n    traits::{Deserialize, FromField},\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "153": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use crate::utils::array;\nuse dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: array::subarray(fields, 1 + LEAF_PREIMAGE_LENGTH),\n    }\n}\n"
    },
    "154": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::{\n    abis::validation_requests::{\n        key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n    },\n    traits::Deserialize,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "155": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "158": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::discovery::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "161": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress,\n    point::{Point, POINT_LENGTH},\n    traits::Deserialize,\n};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(\n    address: AztecAddress,\n    ephPk: Point,\n) -> [Field; POINT_LENGTH] {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    let fields = get_shared_secret_oracle(address, ephPk);\n    Point::deserialize(fields)\n}\n"
    },
    "162": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "171": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "186": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "188": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "189": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "190": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "192": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "193": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "195": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "197": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "201": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "219": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "255": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "262": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "263": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH,\n    traits::{Deserialize, Empty, Packable, Serialize, ToField},\n};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl Packable<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn pack(self) -> [Field; ETH_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "277": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "279": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "280": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "290": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "294": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "296": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "297": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "306": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "331": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "335": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "336": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "352": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "353": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "355": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "367": {
      "path": "/Users/yash/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "390": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "54": {
      "path": "/Users/yash/Development/hackathons/trifectra/token-bridge-tutorial/token-bridge-tutorial/zk-lending-protocol/lending/src/main.nr",
      "source": "mod util;\n\n// Demonstrates how to use portal contracts to swap on L1 Uniswap with funds on L2\n// Has two separate flows for private and public respectively\n// Uses the token bridge contract, which tells which input token we need to talk to and handles the exit funds to L1\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector, PublicImmutable};\n\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit_public, compute_authwit_message_hash_from_call,\n        set_authorized,\n    };\n\n    use crate::util::{compute_lend_private_content_hash, compute_lend_public_content_hash};\n    use dep::aztec::macros::{functions::{initializer, internal, private, public}, storage::storage};\n    use dep::token::Token;\n    use dep::token_bridge::TokenBridge;\n\n    use dep::aztec::protocol_types::traits::ToField;\n\n    #[storage]\n    struct Storage<Context> {\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal_address: EthAddress) {\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[public]\n    fn lend_public(\n        sender: AztecAddress,\n        input_asset_bridge: AztecAddress,\n        input_amount: u128,\n        // params for using the transfer approval\n        nonce_for_transfer_approval: Field,\n        recipient: AztecAddress,\n        secret_hash_for_L1_to_l2_message: Field,\n        caller_on_L1: EthAddress,\n        // nonce for someone to call lend on sender's behalf\n        nonce_for_lend_approval: Field,\n    ) {\n        if (!sender.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, sender);\n        }\n\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config_public().view(&mut context);\n\n        let input_asset = input_asset_bridge_config.token;\n        let input_asset_bridge_portal_address = input_asset_bridge_config.portal;\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_in_public(\n                sender,\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Lending::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .call(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        \n        let content_hash = compute_lend_public_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            recipient,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n\n    #[private]\n    fn lend_private(\n        input_asset: AztecAddress, // since private, we pass here and later assert that this is as expected by input_bridge\n        input_asset_bridge: AztecAddress,\n        input_amount: u128,\n        // params for using the transfer_to_public approval\n        nonce_for_transfer_to_public_approval: Field,\n        // params for the depositing output_asset back to Aztec\n        secret_hash_for_L1_to_l2_message: Field, // for when l1 uniswap portal inserts the message to consume output assets on L2\n        caller_on_L1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n    ) {\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config().view(&mut context);\n\n\n        // Assert that user provided token address is same as expected by token bridge.\n        // we can't directly use `input_asset_bridge.token` because that is a public method and public can't return data to private\n        assert(\n            input_asset.eq(input_asset_bridge_config.token),\n            \"input_asset address is not the same as seen in the bridge contract\",\n        );\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_to_public(\n                context.msg_sender(),\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_to_public_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Lending::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .enqueue(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_lend_private_content_hash(\n            input_asset_bridge_config.portal,\n            input_amount,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n\n    // This helper method approves the bridge to burn this contract's funds and exits the input asset to L1\n    // Assumes contract already has funds.\n    // Assume `token` relates to `token_bridge` (ie token_bridge.token == token)\n    // Note that private can't read public return values so created an internal public that handles everything\n    // this method is used for both private and public swaps.\n    #[public]\n    #[internal]\n    fn _approve_bridge_and_exit_input_asset_to_L1(\n        token: AztecAddress,\n        token_bridge: AztecAddress,\n        amount: u128,\n    ) {\n        // Since we will authorize and instantly spend the funds, all in public, we can use the same nonce\n        // every interaction. In practice, the authwit should be squashed, so this is also cheap!\n        let nonce = 0xdeadbeef;\n\n        let selector = FunctionSelector::from_signature(\"burn_public((Field),u128,Field)\");\n        let message_hash = compute_authwit_message_hash_from_call(\n            token_bridge,\n            token,\n            context.chain_id(),\n            context.version(),\n            selector,\n            [context.this_address().to_field(), amount as Field, nonce],\n        );\n\n        // We need to make a call to update it.\n        set_authorized(&mut context, message_hash, true);\n\n        let this_portal_address = storage.portal_address.read();\n        // Exit to L1 Uniswap Portal !\n        TokenBridge::at(token_bridge)\n            .exit_to_l1_public(this_portal_address, amount, this_portal_address, nonce)\n            .call(&mut context)\n    }    \n}"
    },
    "55": {
      "path": "/Users/yash/Development/hackathons/trifectra/token-bridge-tutorial/token-bridge-tutorial/zk-lending-protocol/lending/src/util.nr",
      "source": "use dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::{hash::sha256_to_field, traits::ToField};\n\n// This method computes the L2 to L1 message content hash for the public\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_lend_public_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: u128,\n    aztec_recipient: AztecAddress,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 164]; // 5 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let aztec_recipient_bytes: [u8; 32] = aztec_recipient.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"lend_public(address,uint256,bytes32,bytes32,address)\".as_bytes(),\n            52,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = aztec_recipient_bytes[i];\n        hash_bytes[i + 100] =secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 132] =caller_on_L1_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n\n// This method computes the L2 to L1 message content hash for the private\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_lend_private_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: u128,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 132]; // 4 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"lend_private(address,uint256,bytes32,address)\".as_bytes(),\n            45,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 100] = caller_on_L1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n\n"
    },
    "57": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "66": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "73": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "76": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "78": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal NOTE_PRIVATE_LOG_RESERVED_FIELDS: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size, encryption\n/// overhead and extra fields in the log (e.g. the combined log and note type ID).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - NOTE_PRIVATE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of note discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note_content, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note_content */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the note discovery process, in which private and public logs are downloaded and inspected to find private\n/// notes, partial notes, and their completion. This is the mechanism via which PXE learns of new notes.\n///\n/// Receives the address of the contract on which discovery is performed (i.e. the contract that emitted the notes)\n/// along with its `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_notes<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing note discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "79": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{discovery::{ComputeNoteHashAndNullifier, MAX_NOTE_PACKED_LEN}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting note discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note_content,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "80": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n        private_logs::MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN,\n    },\n    oracle::note_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = &mut 0;\n    whyle(\n        || *i < pending_partial_notes.len(),\n        || {\n            let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(*i);\n\n            let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n            if maybe_log.is_none() {\n                debug_log_format(\n                    \"Found no completion logs for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                *i += 1 as u32;\n                // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n                // for this tagged log when performing note discovery in the future until we either find it or the entry\n                // is somehow removed from the PXE DB.\n            } else {\n                debug_log_format(\n                    \"Completion log found for partial note with tag {}\",\n                    [pending_partial_note.note_completion_log_tag],\n                );\n                let log = maybe_log.unwrap();\n\n                // Public logs have an extra field at the beginning with the contract address, which we use to verify\n                // that we're getting the logs from the expected contract.\n                // TODO(#10273): improve how contract log siloing is handled\n                assert_eq(\n                    log.log_content.get(0),\n                    contract_address.to_field(),\n                    \"Got a public log emitted by a different contract\",\n                );\n\n                // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n                // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n                // complete packed content.\n                let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                    array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n                let complete_packed_note_content = array::append(\n                    pending_partial_note.packed_private_note_content,\n                    packed_public_note_content,\n                );\n\n                let discovered_notes = attempt_note_nonce_discovery(\n                    log.unique_note_hashes_in_tx,\n                    log.first_nullifier_in_tx,\n                    compute_note_hash_and_nullifier,\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.note_type_id,\n                    complete_packed_note_content,\n                );\n\n                debug_log_format(\n                    \"Discovered {0} notes for partial note with tag {1}\",\n                    [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n                );\n\n                array::for_each_in_bounded_vec(\n                    discovered_notes,\n                    |discovered_note: DiscoveredNoteInfo, _| {\n                        // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                        // temporary node connectivity issue - is simply throwing good enough here?\n                        assert(\n                            deliver_note(\n                                contract_address,\n                                pending_partial_note.storage_slot,\n                                discovered_note.nonce,\n                                complete_packed_note_content,\n                                discovered_note.note_hash,\n                                discovered_note.inner_nullifier,\n                                log.tx_hash,\n                                pending_partial_note.recipient,\n                            ),\n                            \"Failed to deliver note\",\n                        );\n                    },\n                );\n\n                // Because there is only a single log for a given tag, once we've processed the tagged log then we\n                // simply delete the pending work entry, regardless of whether it was actually completed or not.\n                // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n                // being completed.\n                pending_partial_notes.remove(*i);\n\n                // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n                // shifts the elements to the left if the removed element is not the last element.\n            }\n        },\n    );\n}\n\n/// Custom version of a while loop, calls `body` repeatedly until `condition` returns false. To be removed once Noir\n/// supports looping in unconstrained code.\nfn whyle<Env, Env2>(condition: fn[Env]() -> bool, body: fn[Env2]() -> ()) {\n    if condition() {\n        body();\n        whyle(condition, body);\n    }\n}\n"
    },
    "81": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    capsules::CapsuleArray,\n    oracle::note_discovery::{deliver_note, sync_notes},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier,\n    MAX_NOTE_PACKED_LEN,\n    nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    NOTE_PRIVATE_LOG_RESERVED_FIELDS,\n    partial_notes::{\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT, DeliveredPendingPartialNote,\n    },\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\npub global PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN: u32 = 1;\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (i.e.\n/// the note completion log tag).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_NOTE_PACKED_LEN - PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes. Private\n/// notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash in\n/// which the notes would've been created (typically the same transaction in which the log was emitted), along with the\n/// list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (storage_slot, note_type_id, log_type_id, log_payload) =\n        destructure_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        attempt_note_discovery(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            storage_slot,\n            note_type_id,\n            log_payload,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            log_payload,\n            recipient,\n        );\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id],\n        );\n    }\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_PRIVATE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_PRIVATE_LOG_RESERVED_FIELDS == 2,\n        \"unexpected value for NOTE_PRIVATE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n\n    // We currently identify log types by packing the log type ID and note type ID into a single field, called the\n    // combined type ID. We can do this because the note type ID is only 7 bits long, and so use an 8th bit to\n    // distinguish private note logs and partial note logs.\n    // This abuses the fact that the encoding of both of these logs is extremely similar, and will need improving and\n    // more formalization once we introduce other dissimilar log types, such as events. Ideally we'd be able to\n    // leverage enums and tagged unions to achieve this goal.\n    let combined_type_id = log_plaintext.get(1);\n    let note_type_id = ((combined_type_id as u64) % 128) as Field;\n    let log_type_id = ((combined_type_id as u64) / 128) as Field;\n\n    let log_payload = array::subbvec(log_plaintext, NOTE_PRIVATE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, log_type_id, log_payload)\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note_content: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note_content,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note_content,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nunconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    log_payload: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    recipient: AztecAddress,\n) {\n    // We store the information of the partial note we found so that we can later search for the public log that will\n    // complete it. The tag is the first value in the payload, with the packed note content taking up the rest of it.\n    static_assert(\n        PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN == 1,\n        \"unexpected value for PARTIAL_NOTE_COMPLETION_LOG_TAG_LEN\",\n    );\n\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag: log_payload.get(0),\n        storage_slot,\n        note_type_id,\n        packed_private_note_content: array::subbvec(log_payload, 1),\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n"
    },
    "82": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "88": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for note discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::{FromField, Serialize}};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn test_encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret.serialize());\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "95": {
      "path": "/Users/yash/nargo/github.com/AztecProtocol/aztec-packages/v0.81.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
